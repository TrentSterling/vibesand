
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>VibeSand - Ultimate GPU Playground</title>
      <style>
         :root {
         --base-padding: 16px;
         --accent-color: #00d4ff;
         --accent-glow: rgba(0, 212, 255, 0.3);
         --glass-bg: rgba(15, 20, 30, 0.65);
         --glass-border: rgba(255, 255, 255, 0.12);
         --text-primary: #ffffff;
         --text-secondary: #a8b4c0;
         --text-muted: #6b7785;
         --border-radius: 12px;
         --border-radius-sm: 8px;
         --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
         }
         
         * { box-sizing: border-box; }
         
         html, body { 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: var(--text-primary);
            font-size: 14px;
         }
         
         #canvas-container { 
            width: 100%; 
            height: 100%; 
            display: block; 
            position: relative; 
         }
         
         canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            background-color: #0d0d1a; 
            cursor: crosshair; 
         }
         
         /* Frosted Glass Panel Base */
         .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
         }
         
         /* Control Panel - Responsive Layout */
         #controlPanel {
            position: fixed;
            z-index: 100;
            transition: var(--transition);
            padding: 20px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
         }
         
         #controlPanel::-webkit-scrollbar {
            width: 6px;
         }
         
         #controlPanel::-webkit-scrollbar-track {
            background: transparent;
         }
         
         #controlPanel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
         }
         
         #controlPanel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
         }
         
         /* Landscape: Sidebar on left */
         @media (orientation: landscape) {
            #controlPanel {
               top: 16px;
               left: 16px;
               width: 280px;
               max-height: calc(100vh - 32px);
            }
         }
         
         /* Portrait: Bottom bar */
         @media (orientation: portrait) {
            #controlPanel {
               bottom: 16px;
               left: 16px;
               right: 16px;
               width: auto;
               max-height: 45vh;
            }
         }
         
         /* Panel Header */
         .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
         }
         
         .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
         }
         
         .stats-display {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--text-secondary);
         }
         
         .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
         }
         
         .stat-label {
            color: var(--text-muted);
         }
         
         /* Control Sections */
         .control-section {
            margin-bottom: 20px;
         }
         
         .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 10px;
         }
         
         /* Button Groups */
         .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
         }
         
         .glass-button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 8px 14px;
            border-radius: var(--border-radius-sm);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            flex: 1;
            min-width: fit-content;
         }
         
         .glass-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
         }
         
         .glass-button.active {
            background: linear-gradient(135deg, var(--accent-color), #0099cc);
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         .glass-button.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px var(--accent-glow);
         }
         
         /* Slider Controls */
         .slider-control {
            margin-bottom: 14px;
         }
         
         .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            color: var(--text-secondary);
         }
         
         .slider-value {
            font-weight: 600;
            color: var(--accent-color);
            font-size: 12px;
         }
         
         input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
         }
         
         input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 2px 8px var(--accent-glow);
            transition: var(--transition);
         }
         
         input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px var(--accent-glow);
            transition: var(--transition);
         }
         
         input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         /* Select Dropdown */
         select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: var(--transition);
         }
         
         select:hover, select:focus {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--accent-color);
            outline: none;
         }
         
         /* Checkbox */
         .checkbox-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
            cursor: pointer;
            user-select: none;
         }
         
         .checkbox-control input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-color);
         }
         
         .checkbox-control label {
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            flex: 1;
         }
         
         /* Info Toggle Button */
         #infoToggleButton {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 101;
            padding: 10px 16px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
         }
         
         #infoToggleButton:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
         }
         
         /* Info Panel */
         #descriptionArea {
            position: fixed;
            top: 60px;
            right: 16px;
            width: min(400px, calc(100vw - 32px));
            max-height: calc(100vh - 92px);
            padding: 24px;
            z-index: 100;
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0s;
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
         }
         
         #descriptionArea::-webkit-scrollbar {
            width: 6px;
         }
         
         #descriptionArea::-webkit-scrollbar-track {
            background: transparent;
         }
         
         #descriptionArea::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
         }
         
         #descriptionArea.hidden {
            opacity: 0;
            transform: translateY(-20px);
            visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0.3s;
         }
         
         #descriptionArea h2 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-color);
         }
         
         #descriptionArea h4 {
            margin: 16px 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
         }
         
         #descriptionArea p {
            margin: 0 0 12px 0;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
         }
         
         #descriptionArea ul {
            margin: 0 0 12px 0;
            padding-left: 20px;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
         }
         
         #descriptionArea li {
            margin-bottom: 6px;
         }
         
         #descriptionArea code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: var(--accent-color);
         }
         
         #descriptionArea a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
         }
         
         #descriptionArea a:hover {
            text-decoration: underline;
         }
         
         .credits {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--glass-border);
            font-size: 12px;
            text-align: center;
            color: var(--text-muted);
         }
         
         /* Instructions */
         #instructions {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            font-size: 12px;
            color: var(--text-secondary);
            z-index: 40;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
         }
         
         @media (orientation: portrait) {
            #instructions {
               bottom: auto;
               top: 16px;
               left: 50%;
            }
         }
         
         /* First Person HUD */
         #firstPersonHUD {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 60;
         }
         
         #firstPersonHUD::before,
         #firstPersonHUD::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
         }
         
         #firstPersonHUD::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
         }
         
         #firstPersonHUD::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
         }
         
         /* Responsive adjustments */
         @media (max-width: 768px) {
            #controlPanel {
               padding: 16px;
            }
            
            .button-group {
               gap: 6px;
            }
            
            .glass-button {
               padding: 7px 12px;
               font-size: 12px;
            }
            
            @media (orientation: landscape) {
               #controlPanel {
                  width: 240px;
               }
            }
         }
         
         @media (max-width: 480px) {
            #descriptionArea {
               width: calc(100vw - 32px);
            }
            
            @media (orientation: portrait) {
               #controlPanel {
                  max-height: 50vh;
               }
            }
         }
      </style>
   </head>
   <body>
      <button id="infoToggleButton">â„¹ï¸ Info</button>
      <div id="descriptionArea" class="glass-panel">
         <h2>VibeSand 0.2</h2>
         <p style="font-size: 12px; margin-top: -4px; margin-bottom: 16px;">GPU-Powered Voxel Playground</p>
         <p style="color: var(--accent-color); font-weight: 600; margin-bottom: 12px;">ğŸ’¡ Performance Tip: Adjust Render Scale if slow</p>
         <p><strong>VibeSand</strong> is a WebGPU voxel engine. It simulates millions of particles entirely on your GPU. Watch sand form natural piles, water fill basins and flow over edges, and sculpt the world in real time, all illuminated by dynamic lights.</p>
         <h4>Things to Try:</h4>
         <ul style="font-size: 0.9em;">
            <li>Sculpt a stone bowl or pyramid; observe how sand tumbles down slopes and water cascades, lit by the falling lights. Water voxels now have a subtle internal shimmer and appear more luminous.</li>
            <li>Create stair-step patterns; watch particles navigate edges, sliding and collecting in corners.</li>
            <li>Drop blobs of sand into water; see how particles sift, settle, and displace the water.</li>
            <li>Use the "Destroy" tool to punch a hole in the floor beneath water or sand; watch it drain.</li>
            <li>Crank up the <code>Sim Steps</code> slider, then use the Water tool to create fast-moving waves.</li>
            <li>Experiment with the <code>Max Ray Steps</code> slider (capped at 384) to see how it affects visuals and performance.</li>
            <li>Build dams; see how water pressure affects flow when you release it.</li>
         </ul>
         <h4>Key Features</h4>
         <ul style="font-size: 12px;">
            <li><strong>Dynamic Particles & Lighting:</strong> Sand slides naturally, water flows with enhanced shimmer, illuminated by colorful point lights</li>
            <li><strong>Full GPU Pipeline:</strong> Physics, targeting, lighting, and rendering all run on GPU shaders</li>
            <li><strong>Interactive Tools:</strong> Sculpt with sand, stone, water, or erase with clear visual previews</li>
            <li><strong>Single-Pass Rendering:</strong> DDA raymarching renders everything in one go</li>
         </ul>
         <h4>Controls</h4>
         <ul style="font-size: 12px;">
            <li><strong>Orbital Mode:</strong> Right-click to orbit, Middle/Space+Left to pan, Wheel to zoom</li>
            <li><strong>First Person Mode:</strong> WASD to move, Space to jump, Mouse to look (Smooth Minecraft-like movement: instant response, realistic physics, auto-climbs stairs)</li>
         </ul>
         <p class="credits">
            Vibecoded <span id="currentDate"></span> by
            <a href="https://tront.xyz" target="_blank">Trent Sterling</a> & AI
         </p>
      </div>
      
      <div id="controlPanel" class="glass-panel">
         <div class="panel-header">
            <div class="panel-title">
               ğŸ® VibeSand
            </div>
            <div class="stats-display">
               <div class="stat-item">
                  <span class="stat-label">FPS:</span>
                  <span id="fps">0</span>
               </div>
               <div class="stat-item">
                  <span class="stat-label">Voxels:</span>
                  <span id="voxelCount">0</span>
               </div>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">World</div>
            <div class="button-group">
               <button id="worldTypeTerrain" class="glass-button active">ğŸ”ï¸ Terrain</button>
               <button id="worldTypeFlat" class="glass-button">â¬œ Flat</button>
            </div>
            <div class="button-group" style="margin-top: 8px;">
               <button id="resetSimButton" class="glass-button" style="flex: 2;">ğŸ”„ Reset</button>
               <button id="clearLooseButton" class="glass-button" style="flex: 1;">ğŸ§¹ Clear</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Tool</div>
            <div class="button-group">
               <button id="toolPaintSand" class="glass-button active">ğŸ–ï¸ Sand</button>
               <button id="toolPaintStone" class="glass-button">ğŸª¨ Stone</button>
            </div>
            <div class="button-group" style="margin-top: 8px;">
               <button id="toolPaintWater" class="glass-button">ğŸ’§ Water</button>
               <button id="toolDestroy" class="glass-button">ğŸ’¥ Destroy</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Brush</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Size</span>
                  <span class="slider-value" id="brushSizeValue">10.5</span>
               </div>
               <input type="range" id="brushSize" min="1" max="25" step="0.5" value="10.5">
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Simulation</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Steps/Frame</span>
                  <span class="slider-value" id="simStepsValue">1</span>
               </div>
               <input type="range" id="simSteps" min="0" max="25" step="1" value="1">
            </div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Sun Speed</span>
                  <span class="slider-value" id="sunSpeedValue">0.0200</span>
               </div>
               <input type="range" id="sunSpeed" min="0" max="0.02" step="0.0001" value="0.02">
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Rendering</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Max Ray Steps</span>
                  <span class="slider-value" id="maxRayStepsValue">384</span>
               </div>
               <input type="range" id="maxRaySteps" min="64" max="384" step="32" value="384">
            </div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Render Scale</span>
                  <span class="slider-value" id="resolutionScaleValue">100%</span>
               </div>
               <select id="resolutionScale">
                  <option value="1.0">Native (100%)</option>
                  <option value="0.75">High (75%)</option>
                  <option value="0.5">Medium (50%)</option>
                  <option value="0.25">Low (25%)</option>
               </select>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Camera</div>
            <div class="button-group">
               <button id="cameraModeOrbital" class="glass-button active">ğŸ”„ Orbital</button>
               <button id="cameraModeFirstPerson" class="glass-button">ğŸ® FPS</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Options</div>
            <div class="checkbox-control">
               <input type="checkbox" id="continuousPaintToggle" checked>
               <label for="continuousPaintToggle">Continuous Paint</label>
            </div>
            <div class="checkbox-control">
               <input type="checkbox" id="targetFarFaceToggle" checked>
               <label for="targetFarFaceToggle">Target Far Face (on air)</label>
            </div>
         </div>
      </div>
      
      <div id="firstPersonHUD" style="display: none;"></div>
      <div id="canvas-container">
         <canvas id="webgpu-canvas"></canvas>
      </div>
      <div id="instructions">
         <span id="orbitalInstructions">Right-click to orbit â€¢ Middle-mouse/Space+Left to pan</span>
         <span id="firstPersonInstructions" style="display:none;">WASD to move â€¢ Space to jump â€¢ Mouse to look â€¢ Click to lock cursor</span>
      </div>
      <script type="module">
         // ==================================================
         // ğŸ“š å¯è°ƒå‚æ•°æ–‡æ¡£ | Adjustable Parameters Documentation
         // ==================================================
         /*
         
         âš™ï¸ æ ¸å¿ƒå‚æ•° | Core Parameters
         ================================
         
         1. VOXEL_GRID_SIZE (ä½“ç´ ç½‘æ ¼å¤§å°)
            ä½ç½®: ç¬¬769è¡Œé™„è¿‘
            å½“å‰å€¼: 128
            èŒƒå›´: 32, 64, 128, 256 (å¿…é¡»æ˜¯2çš„å¹‚æ¬¡æ–¹)
            æ•ˆæœ: 
            - æ›´å¤§ â†’ æ›´å¤šç»†èŠ‚ï¼Œæ›´å¤§çš„ä¸–ç•Œï¼Œä½†æ€§èƒ½æ˜¾è‘—é™ä½
            - æ›´å° â†’ æ›´å¥½çš„æ€§èƒ½ï¼Œä½†ä¸–ç•Œæ›´å°ï¼Œç»†èŠ‚æ›´å°‘
            æ³¨æ„: ä¿®æ”¹åéœ€è¦é‡æ–°ç”Ÿæˆä¸–ç•Œ
         
         2. NUM_LIGHTS (å…‰æºæ•°é‡)
            ä½ç½®: ç¬¬786è¡Œé™„è¿‘
            å½“å‰å€¼: 32
            èŒƒå›´: 8-64
            æ•ˆæœ:
            - æ›´å¤š â†’ æ›´ä¸°å¯Œçš„ç…§æ˜æ•ˆæœï¼Œä½†é™ä½æ€§èƒ½
            - æ›´å°‘ â†’ æé«˜æ€§èƒ½ï¼Œä½†ç…§æ˜æ•ˆæœè¾ƒå°‘
            å»ºè®®: 16-32ä¹‹é—´å¹³è¡¡æ€§èƒ½å’Œè§†è§‰æ•ˆæœ
         
         3. PAN_SENSITIVITY (ç›¸æœºå¹³ç§»çµæ•åº¦)
            ä½ç½®: ç¬¬782è¡Œé™„è¿‘
            å½“å‰å€¼: 0.1
            èŒƒå›´: 0.05-0.5
            æ•ˆæœ:
            - æ›´å¤§ â†’ é¼ æ ‡æ‹–åŠ¨æ—¶ç›¸æœºç§»åŠ¨æ›´å¿«
            - æ›´å° â†’ ç›¸æœºç§»åŠ¨æ›´æ…¢ï¼Œæ›´ç²¾ç¡®æ§åˆ¶
         
         
         ğŸ’¡ å…‰æºå‚æ•° | Light Parameters
         ================================
         
         4. lights[i].radius (å…‰æºåŠå¾„)
            ä½ç½®: ç¬¬798è¡Œé™„è¿‘
            å½“å‰å€¼: 20.0 + Math.random() * 15 (20-35)
            èŒƒå›´: 10-50
            æ•ˆæœ:
            - æ›´å¤§ â†’ å…‰ç…§è¦†ç›–æ›´å¤§çš„åŒºåŸŸ
            - æ›´å° â†’ å…‰ç…§æ›´é›†ä¸­
            ç¤ºä¾‹ä¿®æ”¹: radius: 30.0 (å›ºå®šåŠå¾„30)
         
         5. lights[i].velocity (å…‰æºä¸‹è½é€Ÿåº¦)
            ä½ç½®: ç¬¬800è¡Œé™„è¿‘
            å½“å‰å€¼: -20.0 - Math.random() * 20.0 (-20åˆ°-40)
            èŒƒå›´: -60 åˆ° -5
            æ•ˆæœ:
            - æ›´è´Ÿ â†’ å…‰æºä¸‹è½æ›´å¿«
            - æ¥è¿‘0 â†’ å…‰æºä¸‹è½æ›´æ…¢æˆ–æ‚¬æµ®
            ç¤ºä¾‹ä¿®æ”¹: velocity: -10.0 (æ…¢é€Ÿä¸‹è½)
         
         6. lights[i].color (å…‰æºé¢œè‰²)
            ä½ç½®: ç¬¬795è¡Œé™„è¿‘
            å½“å‰: HSVtoRGB(Math.random(), 0.9, 1.0) (éšæœºå½©è‰²)
            æ•ˆæœ:
            - HSVtoRGB(0, 0.9, 1.0) â†’ çº¯çº¢è‰²å…‰æº
            - HSVtoRGB(0.33, 0.9, 1.0) â†’ çº¯ç»¿è‰²å…‰æº
            - HSVtoRGB(0.66, 0.9, 1.0) â†’ çº¯è“è‰²å…‰æº
            - HSVtoRGB(0, 0, 1.0) â†’ ç™½è‰²å…‰æº
            ç¤ºä¾‹: æ‰€æœ‰å…‰æºéƒ½æ˜¯æš–é»„è‰²
            color: HSVtoRGB(0.15, 0.8, 1.0)
         
         
         â˜€ï¸ ç¯å¢ƒå‚æ•° | Environment Parameters
         ================================
         
         7. sunSpeed (å¤ªé˜³æ—‹è½¬é€Ÿåº¦)
            ä½ç½®: UIæ§åˆ¶ï¼Œç¬¬812è¡Œé™„è¿‘
            å½“å‰å€¼: 0.02
            èŒƒå›´: 0-0.05
            æ•ˆæœ:
            - æ›´å¤§ â†’ æ—¥å¤œå¾ªç¯æ›´å¿«
            - 0 â†’ å¤ªé˜³é™æ­¢ä¸åŠ¨
            - è´Ÿå€¼ â†’ å¤ªé˜³åå‘æ—‹è½¬
         
         8. sunAngle (åˆå§‹å¤ªé˜³è§’åº¦)
            ä½ç½®: ç¬¬801è¡Œé™„è¿‘
            å½“å‰å€¼: Math.PI / 4
            èŒƒå›´: 0 åˆ° 2*Math.PI
            æ•ˆæœ:
            - 0 â†’ å¤ªé˜³åœ¨ä¸œæ–¹
            - Math.PI/2 â†’ å¤ªé˜³åœ¨å—æ–¹
            - Math.PI â†’ å¤ªé˜³åœ¨è¥¿æ–¹
            - 3*Math.PI/2 â†’ å¤ªé˜³åœ¨åŒ—æ–¹
         
         
         ğŸ¨ æ¸²æŸ“å‚æ•° | Rendering Parameters
         ================================
         
         9. maxRaySteps (æœ€å¤§å…‰çº¿è¿½è¸ªæ­¥æ•°)
            ä½ç½®: UIæ§åˆ¶ï¼Œç¬¬833è¡Œé™„è¿‘
            å½“å‰å€¼: 384
            èŒƒå›´: 64-512
            æ•ˆæœ:
            - æ›´å¤š â†’ å¯ä»¥çœ‹å¾—æ›´è¿œï¼Œä½†æ€§èƒ½é™ä½
            - æ›´å°‘ â†’ æé«˜æ€§èƒ½ï¼Œä½†è¿œå¤„ç‰©ä½“å¯èƒ½æ¶ˆå¤±
            å»ºè®®: ä½ç«¯GPUä½¿ç”¨128ï¼Œé«˜ç«¯GPUä½¿ç”¨384
         
         10. resolutionScale (æ¸²æŸ“åˆ†è¾¨ç‡ç¼©æ”¾)
             ä½ç½®: UIæ§åˆ¶ï¼Œç¬¬824è¡Œé™„è¿‘
             å½“å‰å€¼: 1.0 (100%)
             èŒƒå›´: 0.25-1.0 (25%-100%)
             æ•ˆæœ:
             - 1.0 â†’ åŸç”Ÿåˆ†è¾¨ç‡ï¼Œæœ€ä½³ç”»è´¨
             - 0.5 â†’ 50%åˆ†è¾¨ç‡ï¼Œæ€§èƒ½æå‡4å€
             - 0.25 â†’ 25%åˆ†è¾¨ç‡ï¼Œæ€§èƒ½æå‡16å€
             æ³¨æ„: é™ä½åˆ†è¾¨ç‡ä¼šä½¿ç”»é¢æ¨¡ç³Š
         
         11. clearValue (èƒŒæ™¯é¢œè‰²)
             ä½ç½®: ç¬¬1934è¡Œé™„è¿‘
             å½“å‰å€¼: [0.1, 0.1, 0.2, 1.0] (æ·±è“è‰²)
             æ ¼å¼: [çº¢, ç»¿, è“, é€æ˜åº¦] (0-1èŒƒå›´)
             æ•ˆæœç¤ºä¾‹:
             - [0, 0, 0, 1] â†’ é»‘è‰²èƒŒæ™¯
             - [1, 1, 1, 1] â†’ ç™½è‰²èƒŒæ™¯
             - [0.5, 0, 0, 1] â†’ æ·±çº¢è‰²èƒŒæ™¯
         
         
         âš¡ ç‰©ç†å‚æ•° | Physics Parameters
         ================================
         
         12. simSteps (æ¯å¸§æ¨¡æ‹Ÿæ­¥æ•°)
             ä½ç½®: UIæ§åˆ¶ï¼Œç¬¬830è¡Œé™„è¿‘
             å½“å‰å€¼: 1
             èŒƒå›´: 0-25
             æ•ˆæœ:
             - 0 â†’ æš‚åœç‰©ç†æ¨¡æ‹Ÿ
             - 1 â†’ æ­£å¸¸é€Ÿåº¦
             - 5+ â†’ å¿«é€Ÿç‰©ç†æ¨¡æ‹Ÿ
             æ³¨æ„: æ›´å¤šæ­¥æ•°ä¼šé™ä½å¸§ç‡
         
         13. brushSize (ç”»ç¬”å¤§å°)
             ä½ç½®: UIæ§åˆ¶ï¼Œç¬¬815è¡Œé™„è¿‘
             å½“å‰å€¼: 10.5
             èŒƒå›´: 1-25
             æ•ˆæœ:
             - æ›´å¤§ â†’ ç»˜åˆ¶æ›´å¤§çš„åŒºåŸŸ
             - æ›´å° â†’ æ›´ç²¾ç»†çš„ç»˜åˆ¶
         
         
         ğŸ“· ç›¸æœºå‚æ•° | Camera Parameters
         ================================
         
         14. camera.radius (è½¨é“ç›¸æœºè·ç¦»)
             ä½ç½®: ç¬¬835è¡Œé™„è¿‘
             å½“å‰å€¼: VOXEL_GRID_SIZE * 1.8
             èŒƒå›´: 50-500
             æ•ˆæœ:
             - æ›´å¤§ â†’ ç›¸æœºç¦»åœºæ™¯æ›´è¿œ
             - æ›´å° â†’ ç›¸æœºç¦»åœºæ™¯æ›´è¿‘
         
         15. camera.target (ç›¸æœºç›®æ ‡ç‚¹)
             ä½ç½®: ç¬¬838è¡Œé™„è¿‘
             å½“å‰å€¼: [VOXEL_GRID_SIZE/2, 30, VOXEL_GRID_SIZE/2]
             æ•ˆæœ: ç›¸æœºå›´ç»•è¿™ä¸ªç‚¹æ—‹è½¬
             ç¤ºä¾‹: [64, 50, 64] (æ›´é«˜çš„è§‚å¯Ÿç‚¹)
         
         16. firstPersonCamera.speed (ç¬¬ä¸€äººç§°ç§»åŠ¨é€Ÿåº¦)
             ä½ç½®: ç¬¬823è¡Œé™„è¿‘
             å½“å‰å€¼: 20.0
             èŒƒå›´: 5.0-50.0
             æ•ˆæœ:
             - æ›´å¤§ â†’ ç§»åŠ¨æ›´å¿«
             - æ›´å° â†’ ç§»åŠ¨æ›´æ…¢ï¼Œæ›´ç²¾ç¡®æ§åˆ¶
         
         
         ğŸ¨ è§†è§‰æ•ˆæœå‚æ•° | Visual Effect Parameters
         =========================================
         
         17. æ°´çš„é¢œè‰² (Water Color)
             ä½ç½®: renderShaderCodeç¬¬1279è¡Œé™„è¿‘
             å½“å‰å€¼: vec3(0.15, 0.45, 0.85) (è“è‰²)
             æ•ˆæœ:
             - vec3(0.1, 0.8, 0.8) â†’ é’è‰²æ°´
             - vec3(0.2, 0.2, 0.9) â†’ æ·±è“è‰²æ°´
             - vec3(0.5, 0.1, 0.6) â†’ ç´«è‰²æ°´(å¹»æƒ³æ•ˆæœ)
         
         18. æ²™å­é¢œè‰² (Sand Color)
             ä½ç½®: renderShaderCodeç¬¬1277è¡Œé™„è¿‘
             å½“å‰å€¼: vec3(0.8, 0.7, 0.4) (é»„è‰²)
             æ•ˆæœ:
             - vec3(1.0, 0.9, 0.6) â†’ äº®é»„è‰²æ²™å­
             - vec3(0.6, 0.4, 0.2) â†’ æ£•è‰²æ²™å­
             - vec3(0.9, 0.3, 0.3) â†’ çº¢è‰²æ²™å­(ç«æ˜Ÿæ•ˆæœ)
         
         19. çŸ³å¤´é¢œè‰² (Stone Color)
             ä½ç½®: renderShaderCodeç¬¬1275è¡Œé™„è¿‘
             å½“å‰å€¼: vec3(0.45) (ç°è‰²)
             æ•ˆæœ:
             - vec3(0.3) â†’ æ›´æ·±çš„ç°è‰²
             - vec3(0.6) â†’ æ›´æµ…çš„ç°è‰²
             - vec3(0.4, 0.5, 0.4) â†’ ç»¿ç°è‰²(è‹”è—“çŸ³å¤´)
         
         
         âš™ï¸ é«˜çº§æ•ˆæœå‚æ•° | Advanced Effect Parameters
         =============================================
         
         20. äº‘å±‚å¯†åº¦ (Cloud Density)
             ä½ç½®: renderShaderCodeç¬¬1372è¡Œé™„è¿‘
             å½“å‰: smoothstep(0.4, 0.7, cloud_density)
             æ•ˆæœ:
             - smoothstep(0.3, 0.6, ...) â†’ æ›´å¤šäº‘
             - smoothstep(0.5, 0.8, ...) â†’ æ›´å°‘äº‘
         
         21. äº‘å±‚é€Ÿåº¦ (Cloud Speed)
             ä½ç½®: renderShaderCodeç¬¬1363è¡Œé™„è¿‘
             å½“å‰: time * 0.02 å’Œ time * 0.05
             æ•ˆæœ:
             - å¢åŠ ç³»æ•° â†’ äº‘ç§»åŠ¨æ›´å¿«
             - å‡å°‘ç³»æ•° â†’ äº‘ç§»åŠ¨æ›´æ…¢
         
         22. å¤ªé˜³å¤§å°å’Œå¼ºåº¦ (Sun Size and Intensity)
             ä½ç½®: renderShaderCodeç¬¬1353-1356è¡Œé™„è¿‘
             å½“å‰: pow(..., 128.0) (ä¸»ç›˜), pow(..., 8.0) (å…‰æ™•)
             æ•ˆæœ:
             - å¢åŠ æŒ‡æ•° â†’ å¤ªé˜³æ›´å°æ›´äº®
             - å‡å°‘æŒ‡æ•° â†’ å¤ªé˜³æ›´å¤§æ›´æŸ”å’Œ
         
         
         ğŸ’¡ å®ç”¨å»ºè®® | Practical Tips
         ============================
         
         æ€§èƒ½ä¼˜åŒ–ç»„åˆ (Performance Optimization):
         - VOXEL_GRID_SIZE: 64
         - NUM_LIGHTS: 16
         - maxRaySteps: 128
         - resolutionScale: 0.5
         - simSteps: 1
         
         è§†è§‰è´¨é‡ç»„åˆ (Visual Quality):
         - VOXEL_GRID_SIZE: 128
         - NUM_LIGHTS: 32
         - maxRaySteps: 384
         - resolutionScale: 1.0
         - simSteps: 2
         
         åˆ›æ„å®éªŒç»„åˆ (Creative Experiments):
         1. å½©è™¹é›¨æ•ˆæœ: ä¿æŒlight coloréšæœºï¼Œå¢åŠ NUM_LIGHTSåˆ°48
         2. æœˆå…‰æ•ˆæœ: sunSpeed: 0, æ‰€æœ‰lightsä¸ºè“ç™½è‰²
         3. ç«æ˜Ÿåœºæ™¯: æ²™å­æ”¹ä¸ºçº¢è‰²ï¼Œå¤©ç©ºæ”¹ä¸ºçº¢è¤è‰²
         4. æ°´ä¸‹ä¸–ç•Œ: æ°´æ”¹ä¸ºç»¿è‰²ï¼Œå¢åŠ æ°´çš„äº®åº¦å‚æ•°
         
         */
         
         // --- Start of UI elements that can be initialized without WebGPU ---
         const infoToggleButtonElement = document.getElementById('infoToggleButton');
         const descriptionAreaElement = document.getElementById('descriptionArea');
         if (infoToggleButtonElement && descriptionAreaElement) {
             // Start with info panel hidden
             descriptionAreaElement.classList.add('hidden');
             infoToggleButtonElement.textContent = 'ğŸ“– Show Info';
             
             infoToggleButtonElement.onclick = () => {
                 descriptionAreaElement.classList.toggle('hidden');
                 infoToggleButtonElement.textContent = descriptionAreaElement.classList.contains('hidden') ? 'ğŸ“– Show Info' : 'âœ–ï¸ Hide Info';
             };
         }

         const currentDateEl = document.getElementById('currentDate');
         if (currentDateEl) {
            try {
                currentDateEl.textContent = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            } catch (e) {
                console.warn("Could not set date:", e);
                currentDateEl.textContent = "Today"; // Fallback
            }
         }

         function displayErrorAndStop(title, message) {
             console.error(`VibeSand Error: ${title} - ${message}`);
             document.body.innerHTML = `
                 <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1a1a2e; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: sans-serif; padding: 20px; box-sizing: border-box; text-align: center; z-index: 200;">
                     <h1 style="color: var(--highlight-color, #ffae5a); margin-bottom: 20px;">${title}</h1>
                     <p style="font-size: 1.1em; max-width: 600px; line-height: 1.6;">${message}</p>
                     <p style="margin-top: 25px; font-size: 0.9em;">Please ensure your browser (e.g., Chrome, Edge) is up-to-date and WebGPU is enabled. You can check <a href="https://webgpureport.org" target="_blank" style="color: var(--accent-color, #00aaff); text-decoration: underline;">WebGPUReport.org</a> for your browser's status.</p>
                     <p style="margin-top: 15px; font-size: 0.9em;">On systems with multiple GPUs (like laptops), make sure your browser is using the dedicated (high-performance) graphics card for WebGPU.</p>
                 </div>`;
             throw new Error(`VibeSand HALTED: ${title}`); // Stop further script execution
         }
         // --- End of non-WebGPU UI ---

         // ==================================================
         // WebGPU åˆå§‹åŒ–å’Œä¸»å‡½æ•° | WebGPU Initialization and Main Function
         // ==================================================
         async function initAndRun() {
             // æ­¥éª¤1: è·å–HTMLç”»å¸ƒå…ƒç´  | Step 1: Get the HTML canvas element
             // ç”»å¸ƒæ˜¯æˆ‘ä»¬ç»˜åˆ¶3Då›¾å½¢çš„åœ°æ–¹ | The canvas is where we'll draw our 3D graphics
             const canvas = document.getElementById('webgpu-canvas');
             if (!canvas) {
                 displayErrorAndStop("Initialization Error", "The canvas element (#webgpu-canvas) was not found in the HTML. The page structure might be broken.");
                 return; // Will not be reached
             }

             // æ­¥éª¤2: æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒWebGPU | Step 2: Check if browser supports WebGPU
             // navigator.gpu æ˜¯æµè§ˆå™¨æä¾›çš„WebGPU APIå…¥å£ | navigator.gpu is the browser's WebGPU API entry point
             if (!navigator.gpu) {
                 displayErrorAndStop("WebGPU Not Supported", "Your browser does not support WebGPU, or it is disabled. VibeSand requires WebGPU to run.");
                 return;
             }

             // æ­¥éª¤3: è¯·æ±‚GPUé€‚é…å™¨ (Adapter) | Step 3: Request GPU Adapter
             // Adapterä»£è¡¨ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç‰©ç†GPU | Adapter represents a physical GPU in the system
             // åœ¨æœ‰å¤šä¸ªGPUçš„ç³»ç»Ÿä¸­ï¼Œæµè§ˆå™¨ä¼šé€‰æ‹©æœ€åˆé€‚çš„ä¸€ä¸ª | On systems with multiple GPUs, browser picks the best one
             let adapter;
             try {
                 adapter = await navigator.gpu.requestAdapter();
             } catch (e) {
                 displayErrorAndStop("WebGPU Adapter Error", `Failed to request a WebGPU adapter. This could be due to outdated drivers, or your browser/OS configuration. Error: ${e.message || e}`);
                 return;
             }

             if (!adapter) {
                 displayErrorAndStop("No WebGPU Adapter Found", "No suitable GPU was found for WebGPU. Your GPU might not support WebGPU, it might be disabled in your browser settings, or your graphics drivers need an update.");
                 return;
             }

             // æ­¥éª¤4: ä»é€‚é…å™¨è¯·æ±‚GPUè®¾å¤‡ (Device) | Step 4: Request GPU Device from Adapter
             // Deviceæ˜¯æˆ‘ä»¬å®é™…ä¸GPUé€šä¿¡çš„å¯¹è±¡ | Device is the object we actually use to communicate with the GPU
             // ä¸€ä¸ªè®¾å¤‡å¯ä»¥åˆ›å»ºç¼“å†²åŒºã€ç®¡çº¿ã€çº¹ç†ç­‰GPUèµ„æº | A device can create buffers, pipelines, textures, and other GPU resources
             let device;
             try {
                 device = await adapter.requestDevice();
             } catch (e) {
                 displayErrorAndStop("WebGPU Device Error", `Failed to obtain a WebGPU device from the adapter. This can happen if the GPU is not fully compatible, due to driver issues, or if the system is under heavy load. Error: ${e.message || e}`);
                 return;
             }

             if (!device) {
                 displayErrorAndStop("WebGPU Device Error", "Failed to obtain a WebGPU device (requestDevice returned null/undefined without rejecting). Please check the browser console for more details.");
                 return;
             }

             // æ­¥éª¤5: é…ç½®ç”»å¸ƒçš„WebGPUä¸Šä¸‹æ–‡ | Step 5: Configure canvas WebGPU context
             // contextæ˜¯ç”»å¸ƒå’ŒGPUä¹‹é—´çš„æ¡¥æ¢ | context is the bridge between canvas and GPU
             const context = canvas.getContext('webgpu');
             // è·å–é¦–é€‰çš„åƒç´ æ ¼å¼ (é€šå¸¸æ˜¯ 'bgra8unorm' æˆ– 'rgba8unorm')
             // Get preferred pixel format (usually 'bgra8unorm' or 'rgba8unorm')
             const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
             // é…ç½®ä¸Šä¸‹æ–‡ï¼šæŒ‡å®šä½¿ç”¨å“ªä¸ªè®¾å¤‡ã€åƒç´ æ ¼å¼ã€é€æ˜åº¦æ¨¡å¼
             // Configure context: specify which device to use, pixel format, alpha mode
             context.configure({ device, format: presentationFormat, alphaMode: 'premultiplied' });

             // ==================================================
             // ğŸ¨ å¯è°ƒå‚æ•°åŒºåŸŸ | Adjustable Parameters Section
             // ==================================================
             // è¿™äº›å‚æ•°å¯ä»¥ä¿®æ”¹ä»¥è·å¾—ä¸åŒçš„è§†è§‰æ•ˆæœ | These parameters can be modified for different visual effects
             
             // âš™ï¸ ä½“ç´ ç½‘æ ¼å¤§å° | Voxel Grid Size
             // èŒƒå›´: 32-256 (å¿…é¡»æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œå¦‚32, 64, 128, 256)
             // Range: 32-256 (must be power of 2, like 32, 64, 128, 256)
             // æ›´å¤§çš„ç½‘æ ¼ = æ›´å¤šç»†èŠ‚ï¼Œä½†æ€§èƒ½æ›´ä½ | Larger grid = more detail, but lower performance
             // æ›´å°çš„ç½‘æ ¼ = æ›´å¥½æ€§èƒ½ï¼Œä½†ç»†èŠ‚è¾ƒå°‘ | Smaller grid = better performance, but less detail
             const VOXEL_GRID_SIZE = 128;
             const NUM_VOXELS = VOXEL_GRID_SIZE ** 3;
             document.getElementById('voxelCount').textContent = NUM_VOXELS.toLocaleString();
             
             // ğŸ–±ï¸ ç›¸æœºå¹³ç§»çµæ•åº¦ | Camera Pan Sensitivity  
             // èŒƒå›´: 0.05-0.5 | Range: 0.05-0.5
             // æ›´å¤§çš„å€¼ = å¹³ç§»æ›´å¿« | Larger value = faster panning
             const PAN_SENSITIVITY = 0.1;
             

             // ğŸ› ï¸ å·¥å…·ç±»å‹å¸¸é‡ | Tool Type Constants
             // è¿™äº›å¸¸é‡å®šä¹‰äº†ä¸åŒçš„ç»˜åˆ¶å·¥å…· | These constants define different painting tools
             const TOOL_PAINT_SAND = 0;   // æ²™å­å·¥å…· | Sand tool
             const TOOL_PAINT_STONE = 1;  // çŸ³å¤´å·¥å…· | Stone tool
             const TOOL_DESTROY = 2;       // é”€æ¯/æ“¦é™¤å·¥å…· | Destroy/erase tool
             const TOOL_PAINT_WATER = 3;   // æ°´å·¥å…· | Water tool

             // ==================================================
             // ğŸ’¡ åŠ¨æ€å…‰æºç³»ç»Ÿ | Dynamic Light System
             // ==================================================
             // ğŸ’¡ å…‰æºæ•°é‡ | Number of Lights
             // èŒƒå›´: 8-64 | Range: 8-64
             // æ›´å¤šå…‰æº = æ›´ä¸°å¯Œçš„ç…§æ˜ï¼Œä½†æ€§èƒ½æ›´ä½ | More lights = richer lighting, but lower performance
             // å»ºè®®: ä¿æŒåœ¨16-32ä¹‹é—´ä»¥è·å¾—è‰¯å¥½çš„æ€§èƒ½/è´¨é‡å¹³è¡¡ | Recommended: keep between 16-32 for good performance/quality balance
             const NUM_LIGHTS = 32;
             const lights = [];
             
             // HSVè½¬RGBçš„è¾…åŠ©å‡½æ•° | HSV to RGB helper function
             // ç”¨äºç”Ÿæˆå½©è‰²å…‰æº | Used to generate colorful lights
             function HSVtoRGB(h, s, v) {
                 let r, g, b, i, f, p, q, t;
                 i = Math.floor(h * 6); f = h * 6 - i;
                 p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);
                 switch (i % 6) {
                     case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
                     case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
                     case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
                 }
                 return [r, g, b];
             }
             
             // åˆå§‹åŒ–æ‰€æœ‰å…‰æº | Initialize all lights
             for (let i = 0; i < NUM_LIGHTS; i++) {
                 lights.push({
                     // ğŸ¨ å…‰æºä½ç½® | Light position (å¯ä»¥ä¿®æ”¹åˆå§‹ä½ç½® | can modify initial position)
                     position: [Math.random() * VOXEL_GRID_SIZE, Math.random() * VOXEL_GRID_SIZE, Math.random() * VOXEL_GRID_SIZE],
                     // ğŸŒˆ å…‰æºé¢œè‰² (HSVè‰²è½®éšæœºé€‰æ‹©) | Light color (randomly selected from HSV color wheel)
                     // ä¿®æ”¹ Math.random() ä¸ºå›ºå®šå€¼(0-1)å¯ä»¥å¾—åˆ°ç‰¹å®šé¢œè‰²çš„å…‰æº | Change Math.random() to fixed value (0-1) for specific color
                     // ä¾‹å¦‚ 0=çº¢è‰², 0.33=ç»¿è‰², 0.66=è“è‰² | e.g., 0=red, 0.33=green, 0.66=blue
                     color: HSVtoRGB(Math.random(), 0.9, 1.0),
                     // ğŸ”¦ å…‰æºåŠå¾„ | Light radius
                     // èŒƒå›´: 10-50 | Range: 10-50  
                     // ä¿®æ”¹è¿™é‡Œå¯ä»¥æ”¹å˜å…‰ç…§èŒƒå›´ | Modify here to change lighting range
                     radius: 20.0 + Math.random() * 15,
                     // â¬‡ï¸ å…‰æºä¸‹è½é€Ÿåº¦ (è´Ÿå€¼è¡¨ç¤ºå‘ä¸‹) | Light falling velocity (negative = downward)
                     // èŒƒå›´: -60 åˆ° -10 | Range: -60 to -10
                     // æ›´è´Ÿçš„å€¼ = ä¸‹è½æ›´å¿« | More negative = falls faster
                     velocity: -20.0 - Math.random() * 20.0,
                 });
             }

             // ==================================================
             // ğŸ® åº”ç”¨çŠ¶æ€å’Œé…ç½® | Application State and Configuration
             // ==================================================
             
             // â˜€ï¸ å¤ªé˜³è§’åº¦ (ç”¨äºæ—¥å¤œå¾ªç¯) | Sun angle (for day/night cycle)
             // èŒƒå›´: 0 åˆ° 2Ï€ | Range: 0 to 2Ï€
             let sunAngle = Math.PI / 4;
             
             // å½“å‰é€‰ä¸­çš„å·¥å…· | Currently selected tool
             let currentTool = TOOL_PAINT_SAND;
             
             // åœ°å½¢ç±»å‹: 1=å±±åœ°åœ°å½¢, 0=å¹³å¦åœ°å½¢ | Terrain type: 1=mountainous terrain, 0=flat terrain
             let currentTerrainType = 1;
             
             // UIæ§åˆ¶å‚æ•° | UI control parameters
             let uiControls = {
                 // â˜€ï¸ å¤ªé˜³æ—‹è½¬é€Ÿåº¦ | Sun rotation speed
                 // èŒƒå›´: 0-0.05 | Range: 0-0.05
                 // æ›´å¤§çš„å€¼ = æ—¥å¤œå¾ªç¯æ›´å¿« | Larger value = faster day/night cycle
                 sunSpeed: 0.02,
                 
                 // ğŸ–Œï¸ ç”»ç¬”å¤§å° | Brush size
                 // èŒƒå›´: 1-25 | Range: 1-25
                 brushSize: 10.5,
                 
                 // æ˜¯å¦è¿ç»­ç»˜åˆ¶ | Whether to paint continuously
                 continuousPaint: true,
                 
                 // å½“å…‰çº¿æ‰“åˆ°ç©ºæ°”æ—¶æ˜¯å¦ç„å‡†è¿œé¢ | Whether to target far face when ray hits air
                 targetFarFaceOnAirHit: true,
                 
                 // ğŸ“ æ¸²æŸ“åˆ†è¾¨ç‡ç¼©æ”¾ | Render resolution scale
                 // èŒƒå›´: 0.25-1.0 (25%-100%) | Range: 0.25-1.0 (25%-100%)
                 // é™ä½å¯ä»¥æé«˜æ€§èƒ½ | Lower to improve performance
                 resolutionScale: 1.0,
                 
                 // ğŸ”„ æ¯å¸§æ¨¡æ‹Ÿæ­¥æ•° | Simulation steps per frame
                 // èŒƒå›´: 0-25 | Range: 0-25
                 // æ›´å¤šæ­¥æ•° = æ›´å¿«çš„ç‰©ç†æ¨¡æ‹Ÿï¼Œä½†æ€§èƒ½æ›´ä½ | More steps = faster physics simulation, but lower performance
                 simSteps: 1,
                 
                 // ğŸ” æœ€å¤§å…‰çº¿è¿½è¸ªæ­¥æ•° | Max ray marching steps
                 // èŒƒå›´: 64-384 | Range: 64-384
                 // æ›´å¤šæ­¥æ•° = æ›´è¿œçš„æ¸²æŸ“è·ç¦»ï¼Œä½†æ€§èƒ½æ›´ä½ | More steps = further render distance, but lower performance
                 maxRaySteps: 384,
             };
             
             // ğŸ“· è½¨é“ç›¸æœºå‚æ•° | Orbital camera parameters
             let camera = {
                 // æ°´å¹³æ—‹è½¬è§’åº¦ | Horizontal rotation angle
                 alpha: -0.5,
                 // å‚ç›´æ—‹è½¬è§’åº¦ | Vertical rotation angle
                 beta: 0.3,
                 // ç›¸æœºè·ç¦»ç›®æ ‡ç‚¹çš„è·ç¦» | Camera distance from target
                 radius: VOXEL_GRID_SIZE * 1.8,
                 // ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹ | Camera target point
                 target: [VOXEL_GRID_SIZE / 2, 30, VOXEL_GRID_SIZE / 2],
             };
             let mouseState = {
                 buttons: [false, false, false], x: 0, y: 0, lastX: 0, lastY: 0, isPainting: false, isOrbiting: false, isPanning: false, hasFiredSingleShot: false,
             };
             let spacebarDown = false;
             let frameCount = 0;
             let isPreviewVisible = true;
             let currentCamX=0, currentCamY=0, currentCamZ=0;
             let currentForward=[0,0,1], currentRight=[1,0,0], currentUp=[0,1,0];
             let cameraMode = 'orbital'; // 'orbital' or 'firstperson'
            
            // ==================================================
            // ğŸ® NEW CPU-Based Player Controller | æ–°çš„CPUç©å®¶æ§åˆ¶å™¨
            // ==================================================
            // Smooth, responsive Minecraft-like movement with continuous collision
            // æµç•…ã€å“åº”çµæ•çš„ç±»Minecraftç§»åŠ¨ï¼Œå¸¦è¿ç»­ç¢°æ’æ£€æµ‹
            let player = {
                // è¿ç»­ä½ç½® (æµ®ç‚¹æ•°ï¼Œéä½“ç´ å¯¹é½) | Continuous position (float, not voxel-aligned)
                position: [VOXEL_GRID_SIZE / 2, VOXEL_GRID_SIZE - 10, VOXEL_GRID_SIZE / 2],
                // é€Ÿåº¦å‘é‡ | Velocity vector
                velocity: [0, 0, 0],
                // è§†è§’æ–¹å‘ | View direction
                yaw: -Math.PI / 2,
                pitch: 0,
                // ç‰©ç†çŠ¶æ€ | Physics state
                isGrounded: false,
                // ç¢°æ’ç›’å°ºå¯¸ | Collision box dimensions
                width: 0.6,    // X and Z axis width (player width)
                height: 1.8,   // Y axis height
                eyeHeight: 1.62, // Eye position from feet (slightly below full height)
                // ç§»åŠ¨å‚æ•° | Movement parameters
                walkSpeed: 4.317,      // blocks per second (Minecraft walking speed)
                sprintSpeed: 5.612,    // blocks per second (not implemented yet)
                jumpVelocity: 8.0,     // blocks per second upward
                gravity: 32.0,         // blocks per secondÂ² downward
                // åœ°é¢ç§»åŠ¨ | Ground movement
                groundAcceleration: 100.0,  // How fast to reach target speed
                groundFriction: 20.0,       // How fast to stop
                // ç©ºä¸­ç§»åŠ¨ | Air movement  
                airAcceleration: 20.0,      // Air control (less than ground)
                airFriction: 2.0,           // Minimal air drag
                // é˜¶æ¢¯è‡ªåŠ¨æ”€çˆ¬ | Step climbing
                stepHeight: 0.6,       // Can step up this high automatically
            };
            
             let keyState = {
                w: false, a: false, s: false, d: false, space: false, shift: false,
             };

             // ==================================================
             // ğŸ“œ WGSLç€è‰²å™¨ä»£ç  - å…¬å…±éƒ¨åˆ† | WGSL Shader Code - Common Section
             // ==================================================
             // WGSL (WebGPU Shading Language) æ˜¯WebGPUä½¿ç”¨çš„ç€è‰²å™¨è¯­è¨€
             // WGSL (WebGPU Shading Language) is the shader language used by WebGPU
             // ç€è‰²å™¨åœ¨GPUä¸Šè¿è¡Œï¼Œé€Ÿåº¦éå¸¸å¿« | Shaders run on the GPU and are very fast
             
             const commonShaderCode = `
                 // ğŸ“¦ ä½“ç´ æ•°æ®ç»“æ„ | Voxel Data Structure
                 // æ¯ä¸ªä½“ç´ ç”¨ä¸€ä¸ª32ä½æ— ç¬¦å·æ•´æ•°å­˜å‚¨ | Each voxel is stored as a 32-bit unsigned integer
                 // è¿™ä¸ªæ•´æ•°åŒ…å«: ç±»å‹ã€å˜ä½“ã€æ›´æ–°æ ‡å¿—ã€RGBå…‰ç…§ä¿¡æ¯ | This integer contains: type, variant, update flag, RGB lighting
                 struct VoxelData {
                     data: atomic<u32>,  // atomicç±»å‹å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶å®‰å…¨è®¿é—® | atomic type allows safe concurrent access
                 };

                 // ğŸ’¡ ç‚¹å…‰æºç»“æ„ | Point Light Structure
                 struct PointLight {
                     pos: vec3<f32>,      // å…‰æº3Dä½ç½® | Light 3D position
                     radius: f32,         // å…‰æºå½±å“åŠå¾„ | Light influence radius
                     color: vec3<f32>,    // å…‰æºRGBé¢œè‰² | Light RGB color
                     intensity: f32,      // å…‰æºå¼ºåº¦ | Light intensity
                 };
                 
                 // ğŸŒ åœºæ™¯å…¨å±€æ•°æ® | Scene Global Data
                 struct SceneUniforms {
                     lights: array<PointLight, ${NUM_LIGHTS}>,  // æ‰€æœ‰å…‰æºçš„æ•°ç»„ | Array of all lights
                     light_count: u32,                           // å…‰æºæ•°é‡ | Number of lights
                 };

                 // ğŸ“· æ¸²æŸ“é€šé“ç»Ÿä¸€å˜é‡ | Render Pass Uniforms
                 // è¿™äº›å˜é‡åœ¨æ¯ä¸€å¸§éƒ½ä¼šæ›´æ–°ï¼Œä¼ é€’ç›¸æœºå’Œæ¸²æŸ“è®¾ç½®åˆ°ç€è‰²å™¨
                 // These variables update every frame, passing camera and render settings to shaders
                 struct RenderPassUniforms {
                     camera_position: vec3<f32>,    // ç›¸æœºä½ç½® | Camera position
                     camera_zoom: f32,               // ç›¸æœºç¼©æ”¾/FOV | Camera zoom/FOV
                     camera_right: vec3<f32>,        // ç›¸æœºå³å‘é‡ | Camera right vector
                     _padr: f32,                     // å¡«å……å¯¹é½ | Padding for alignment
                     camera_up: vec3<f32>,           // ç›¸æœºä¸Šå‘é‡ | Camera up vector
                     _padu: f32,                     // å¡«å……å¯¹é½ | Padding for alignment
                     camera_target_pos: vec3<f32>,   // ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹ | Camera target point
                     _padt: f32,                     // å¡«å……å¯¹é½ | Padding for alignment
                     sun_direction: vec3<f32>,       // å¤ªé˜³æ–¹å‘å‘é‡ | Sun direction vector
                     _pads: f32,                     // å¡«å……å¯¹é½ | Padding for alignment
                     canvas_actual_dims: vec2<f32>,  // ç”»å¸ƒå®é™…åƒç´ å°ºå¯¸ | Canvas actual pixel dimensions
                     max_ray_steps: u32,             // å…‰çº¿è¿½è¸ªæœ€å¤§æ­¥æ•° | Ray marching max steps
                     _pad_mrs: u32,                  // å¡«å……å¯¹é½ | Padding for alignment
                 };

                 // ğŸ–¥ï¸ è®¡ç®—é€šé“ç»Ÿä¸€å˜é‡ | Compute Pass Uniforms
                 // ç”¨äºç‰©ç†æ¨¡æ‹Ÿå’Œäº¤äº’çš„å‚æ•° | Parameters for physics simulation and interaction
                 struct ComputePassUniforms {
                     camera_position: vec3<f32>,     // ç›¸æœºä½ç½® | Camera position
                     camera_zoom: f32,               // ç›¸æœºç¼©æ”¾ | Camera zoom
                     camera_right: vec3<f32>,        // ç›¸æœºå³å‘é‡ | Camera right vector
                     _padr2: f32,
                     camera_up: vec3<f32>,           // ç›¸æœºä¸Šå‘é‡ | Camera up vector
                     _padu2: f32,
                     camera_target_pos: vec3<f32>,   // ç›¸æœºç›®æ ‡ | Camera target
                     _padt2: f32,
                     mouse_pos: vec2<f32>,           // é¼ æ ‡ä½ç½® | Mouse position
                     canvas_dims: vec2<f32>,         // ç”»å¸ƒå°ºå¯¸ | Canvas dimensions
                     brush_size: f32,                // ç”»ç¬”å¤§å° | Brush size
                     is_painting: u32,               // æ˜¯å¦æ­£åœ¨ç»˜åˆ¶ | Whether painting
                     tool_type: u32,                 // å·¥å…·ç±»å‹ | Tool type
                     preview_active: u32,            // é¢„è§ˆæ˜¯å¦æ¿€æ´» | Whether preview is active
                     target_far_face_on_air_hit: u32, // ç›®æ ‡é€‰æ‹©æ¨¡å¼ | Target selection mode
                     frame_num: u32,                 // å¸§ç¼–å· | Frame number
                     max_ray_steps_compute: u32,     // è®¡ç®—ç”¨çš„æœ€å¤§æ­¥æ•° | Max steps for compute
                     _pad_mrs_compute: u32,
                 };

                 // ğŸ¯ ç›®æ ‡è¾“å‡ºç»“æ„ | Targeting Output Structure
                 // ç”¨äºå­˜å‚¨å…‰çº¿è¿½è¸ªæ‰¾åˆ°çš„ç›®æ ‡ä½ç½® | Used to store target position found by ray tracing
                 struct TargetingOutput { 
                     aim_pos: vec4<f32>,  // ç„å‡†ä½ç½® | Aim position
                     hit: u32             // æ˜¯å¦å‘½ä¸­ | Whether hit
                 };

                 // ğŸ§± ä½“ç´ ç±»å‹å¸¸é‡ | Voxel Type Constants
                 // è¿™äº›å¸¸é‡å®šä¹‰äº†ä¸åŒç±»å‹çš„ä½“ç´  | These constants define different voxel types
                 const VOXEL_TYPE_AIR = 0u;      // ç©ºæ°”(é€æ˜) | Air (transparent)
                 const VOXEL_TYPE_STONE = 1u;    // çŸ³å¤´(å›ºä½“) | Stone (solid)
                 const VOXEL_TYPE_SAND = 2u;     // æ²™å­(ä¼šä¸‹è½) | Sand (falls)
                 const VOXEL_TYPE_WATER = 3u;    // æ°´(æµåŠ¨) | Water (flows)

                 // ğŸ› ï¸ å·¥å…·ç±»å‹å¸¸é‡ | Tool Type Constants
                 const TOOL_TYPE_SAND = 0u;
                 const TOOL_TYPE_STONE = 1u;
                 const TOOL_TYPE_DESTROY = 2u;
                 const TOOL_TYPE_WATER = 3u;

                 // ğŸ“ ç½‘æ ¼å°ºå¯¸ | Grid dimension
                 const GRID_DIM = ${VOXEL_GRID_SIZE}u;

                 // ğŸ”¢ ä½æ“ä½œæ©ç å’Œåç§» | Bit manipulation masks and shifts
                 // ç”¨äºå°†å¤šä¸ªå€¼æ‰“åŒ…åˆ°å•ä¸ª32ä½æ•´æ•°ä¸­ | Used to pack multiple values into a single 32-bit integer
                 // è¿™æ ·å¯ä»¥èŠ‚çœGPUå†…å­˜ | This saves GPU memory
                 const MASK_TYPE = 7u;           // 0b111 - ç±»å‹å ç”¨3ä½ | Type uses 3 bits
                 const SHIFT_TYPE = 0u;          // ç±»å‹ä»ç¬¬0ä½å¼€å§‹ | Type starts at bit 0
                 const MASK_VARIANT = 7u;        // 0b111 - å˜ä½“å ç”¨3ä½ | Variant uses 3 bits
                 const SHIFT_VARIANT = 3u;       // å˜ä½“ä»ç¬¬3ä½å¼€å§‹ | Variant starts at bit 3
                 const MASK_UPDATED = 1u;        // 0b1 - æ›´æ–°æ ‡å¿—å ç”¨1ä½ | Updated flag uses 1 bit
                 const SHIFT_UPDATED = 6u;       // æ ‡å¿—ä»ç¬¬6ä½å¼€å§‹ | Flag starts at bit 6

                 const MASK_LIGHT = 255u;        // 0b11111111 - æ¯ä¸ªå…‰ç…§é€šé“8ä½ | Each light channel 8 bits
                 const SHIFT_LIGHT_R = 8u;       // çº¢è‰²é€šé“ä»ç¬¬8ä½å¼€å§‹ | Red channel starts at bit 8
                 const SHIFT_LIGHT_G = 16u;      // ç»¿è‰²é€šé“ä»ç¬¬16ä½å¼€å§‹ | Green channel starts at bit 16
                 const SHIFT_LIGHT_B = 24u;      // è“è‰²é€šé“ä»ç¬¬24ä½å¼€å§‹ | Blue channel starts at bit 24

                 // ğŸ“¦ è§£åŒ…åçš„ä½“ç´ ç»“æ„ | Unpacked Voxel Structure
                 // å°†32ä½æ•´æ•°è§£åŒ…æˆæ˜“äºä½¿ç”¨çš„ç»“æ„ | Unpacks 32-bit integer into easy-to-use structure
                 struct UnpackedVoxel {
                     v_type: u32,        // ä½“ç´ ç±»å‹ | Voxel type
                     v_variant: u32,     // é¢œè‰²å˜ä½“ | Color variant
                     is_updated: u32,    // æœ¬å¸§æ˜¯å¦å·²æ›´æ–° | Whether updated this frame
                     light: vec3<f32>,   // RGBå…‰ç…§å€¼ | RGB lighting value
                 };

                 // ğŸ”“ è§£åŒ…å‡½æ•°ï¼šä»32ä½æ•´æ•°æå–ä½“ç´ ä¿¡æ¯ | Unpack function: extract voxel info from 32-bit integer
                 fn unpackVoxel(data: u32) -> UnpackedVoxel {
                     var result: UnpackedVoxel;
                     // ä½¿ç”¨ä½æ“ä½œæå–æ¯ä¸ªå­—æ®µ | Use bit operations to extract each field
                     result.v_type = (data >> SHIFT_TYPE) & MASK_TYPE;
                     result.v_variant = (data >> SHIFT_VARIANT) & MASK_VARIANT;
                     result.is_updated = (data >> SHIFT_UPDATED) & MASK_UPDATED;
                     // æå–RGBå…‰ç…§å€¼å¹¶å½’ä¸€åŒ–åˆ°0-1èŒƒå›´ | Extract RGB lighting and normalize to 0-1 range
                     let r = f32((data >> SHIFT_LIGHT_R) & MASK_LIGHT);
                     let g = f32((data >> SHIFT_LIGHT_G) & MASK_LIGHT);
                     let b = f32((data >> SHIFT_LIGHT_B) & MASK_LIGHT);
                     result.light = vec3(r, g, b) / 255.0;
                     return result;
                 }

                 // ğŸ”’ æ‰“åŒ…å‡½æ•°ï¼šå°†ä½“ç´ ä¿¡æ¯å‹ç¼©åˆ°32ä½æ•´æ•° | Pack function: compress voxel info into 32-bit integer
                 fn packVoxel(v_type: u32, v_variant: u32, is_updated: u32, light: vec3<f32>) -> u32 {
                     // å°†å…‰ç…§å€¼ä»0-1èŒƒå›´è½¬æ¢åˆ°0-255èŒƒå›´ | Convert lighting from 0-1 range to 0-255 range
                     let r = u32(clamp(light.r * 255.0, 0.0, 255.0));
                     let g = u32(clamp(light.g * 255.0, 0.0, 255.0));
                     let b = u32(clamp(light.b * 255.0, 0.0, 255.0));
                     // ä½¿ç”¨ä½æˆ–æ“ä½œå°†æ‰€æœ‰å­—æ®µç»„åˆåˆ°ä¸€ä¸ªæ•´æ•°ä¸­ | Use bit OR to combine all fields into one integer
                     return ((v_type & MASK_TYPE) << SHIFT_TYPE) |
                            ((v_variant & MASK_VARIANT) << SHIFT_VARIANT) |
                            ((is_updated & MASK_UPDATED) << SHIFT_UPDATED) |
                            ((r & MASK_LIGHT) << SHIFT_LIGHT_R) |
                            ((g & MASK_LIGHT) << SHIFT_LIGHT_G) |
                            ((b & MASK_LIGHT) << SHIFT_LIGHT_B);
                 }

                 // å¿«é€Ÿæå–å‡½æ•°ï¼šåªè·å–ç±»å‹å’Œæ›´æ–°æ ‡å¿— | Fast extract functions: get only type and update flag
                 fn getVoxelType(data: u32) -> u32 { return (data >> SHIFT_TYPE) & MASK_TYPE; }
                 fn getVoxelIsUpdated(data: u32) -> u32 { return (data >> SHIFT_UPDATED) & MASK_UPDATED; }

                 // ğŸ“ åæ ‡è½¬ç´¢å¼•å‡½æ•° | Coordinate to index functions
                 // å°†3Dåæ ‡(x,y,z)è½¬æ¢ä¸º1Dæ•°ç»„ç´¢å¼• | Convert 3D coordinates (x,y,z) to 1D array index
                 // ä½¿ç”¨å…¬å¼: index = x + y*WIDTH + z*WIDTH*HEIGHT | Formula: index = x + y*WIDTH + z*WIDTH*HEIGHT
                 fn pos_to_idx(pos: vec3<u32>) -> u32 {
                     // æ£€æŸ¥åæ ‡æ˜¯å¦è¶Šç•Œ | Check if coordinates are out of bounds
                     if (any(pos >= vec3(GRID_DIM))) { return 0xFFFFFFFFu; }  // è¿”å›æ— æ•ˆç´¢å¼• | Return invalid index
                     return pos.x + pos.y * GRID_DIM + pos.z * GRID_DIM * GRID_DIM;
                 }
                 
                 // å¸¦ç¬¦å·æ•´æ•°ç‰ˆæœ¬ | Signed integer version
                 fn pos_to_idx_i32(pos: vec3<i32>) -> u32 {
                     if (any(pos < vec3(0)) || any(pos >= vec3<i32>(i32(GRID_DIM)))) { return 0xFFFFFFFFu; }
                     return u32(pos.x + pos.y * i32(GRID_DIM) + pos.z * i32(GRID_DIM) * i32(GRID_DIM));
                 }
                 
                 // ğŸ² 3Då“ˆå¸Œå‡½æ•°ï¼šå°†3Dåæ ‡è½¬æ¢ä¸ºä¼ªéšæœºæµ®ç‚¹æ•° | 3D hash function: convert 3D coordinates to pseudo-random float
                 // ç”¨äºç”Ÿæˆéšæœºå˜ä½“å’Œå™ªå£° | Used to generate random variants and noise
                 fn hash3d_to_float(p: vec3<u32>) -> f32 {
                     var p_mut = p * vec3(374761393u, 668265263u, 104395301u);  // å¤§è´¨æ•° | Large primes
                     p_mut = (p_mut ^ p_mut.yzx ^ p_mut.zxy) >> vec3(8u);
                     p_mut = p_mut * vec3(374761393u, 668265263u, 104395301u);
                     return f32(p_mut.x ^ p_mut.y ^ p_mut.z) / 4294967295.0;  // å½’ä¸€åŒ–åˆ°0-1 | Normalize to 0-1
                 }
             `;

             const generationShaderCode = `
                 ${commonShaderCode}
                 struct GenerationUniforms { terrain_type: u32 };
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> gen_uniforms: GenerationUniforms;
                 fn noise(p: vec2<f32>) -> f32 { return sin(p.x*0.1) * cos(p.y*0.1); }
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                     let idx = pos_to_idx(global_id);
                     if (idx == 0xFFFFFFFFu) { return; }
                     var v_type = VOXEL_TYPE_AIR;
                     let variant = u32(hash3d_to_float(global_id) * 8.0);

                     if (gen_uniforms.terrain_type == 1u) {
                         let h = 32.0 + noise(vec2<f32>(global_id.xz)) * 10.0 + noise(vec2<f32>(global_id.xz) * 2.5) * 4.0;
                         if (f32(global_id.y) < h) {
                             v_type = select(VOXEL_TYPE_SAND, VOXEL_TYPE_STONE, f32(global_id.y) < h - 4.0);
                         }
                     } else {
                         if (global_id.y < 5u) {
                             v_type = VOXEL_TYPE_STONE;
                         } else if (global_id.y < 10u && global_id.x > 10u && global_id.x < GRID_DIM - 10u && global_id.z > 10u && global_id.z < GRID_DIM - 10u) {
                             v_type = VOXEL_TYPE_WATER;
                         }
                     }
                     atomicStore(&voxels[idx].data, packVoxel(v_type, variant, 0u, vec3(0.0)));
                 }
             `;

             const simulationShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;

                 fn attempt_move(current_idx: u32, target_idx: u32, current_data: u32) -> bool {
                     let target_initial_data = atomicLoad(&voxels[target_idx].data);
                     if (getVoxelType(target_initial_data) != VOXEL_TYPE_AIR || getVoxelIsUpdated(target_initial_data) == 1u) {
                         return false;
                     }
                     let data_to_write = current_data | (1u << SHIFT_UPDATED);
                     let ex = atomicCompareExchangeWeak(&voxels[target_idx].data, target_initial_data, data_to_write);
                     if (ex.exchanged) {
                         atomicStore(&voxels[current_idx].data, 0u);
                         return true;
                     }
                     return false;
                 }

                 fn attempt_swap(current_idx: u32, target_idx: u32, current_data: u32) -> bool {
                     let target_initial_data = atomicLoad(&voxels[target_idx].data);
                     if (getVoxelIsUpdated(target_initial_data) == 1u) { return false; }

                     let marked_current_data = current_data | (1u << SHIFT_UPDATED);
                     let marked_target_data = target_initial_data | (1u << SHIFT_UPDATED);

                     let ex = atomicCompareExchangeWeak(&voxels[target_idx].data, target_initial_data, marked_current_data);
                     if (ex.exchanged) {
                         let ex2 = atomicCompareExchangeWeak(&voxels[current_idx].data, current_data, marked_target_data);
                         if (!ex2.exchanged) {
                             atomicStore(&voxels[target_idx].data, target_initial_data);
                             return false;
                         }
                         return true;
                     }
                     return false;
                 }

                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                     let current_idx = pos_to_idx(global_id);
                     if (current_idx == 0xFFFFFFFFu) { return; }

                     let initial_data = atomicLoad(&voxels[current_idx].data);
                     let current_type = getVoxelType(initial_data);

                     if (getVoxelIsUpdated(initial_data) == 1u || current_type == VOXEL_TYPE_AIR || current_type == VOXEL_TYPE_STONE) {
                         return;
                     }

                    // Delete loose voxels at bottom
                    if (global_id.y == 0u) {
                        atomicStore(&voxels[current_idx].data, 0u);
                        return;
                    }

                     // PRIORITY 1: Direct Vertical Fall
                     let pos_below = global_id - vec3(0u, 1u, 0u);
                     let idx_below = pos_to_idx(pos_below);
                     if (idx_below != 0xFFFFFFFFu) {
                         let type_below = getVoxelType(atomicLoad(&voxels[idx_below].data));
                         if (type_below == VOXEL_TYPE_AIR) {
                             if (attempt_move(current_idx, idx_below, initial_data)) { return; }
                         } else if ((current_type == VOXEL_TYPE_SAND ) && type_below == VOXEL_TYPE_WATER) {
                             if (attempt_swap(current_idx, idx_below, initial_data)) { return; }
                         }
                     }

                     let time_varied_hash = (global_id.x * 19349663u) ^ (global_id.y * 668265263u) ^ (global_id.z * 374761393u) ^ tool_info.frame_num;

                     // PRIORITY 2: Diagonal Fall
                     if (global_id.y > 0u) {
                         if (current_type == VOXEL_TYPE_SAND ) {
                             let DIAGONAL_SLIDES_SAND = array<vec3<i32>, 8>(
                                 vec3(1,-1,0), vec3(-1,-1,0), vec3(0,-1,1), vec3(0,-1,-1),
                                 vec3(1,-1,1), vec3(-1,-1,1), vec3(1,-1,-1), vec3(-1,-1,-1)
                             );
                             let offset_diag_sand = time_varied_hash % 8u;
                             for(var i_ds = 0u; i_ds < 8u; i_ds = i_ds + 1u) {
                                 let check_pos = vec3<i32>(global_id) + DIAGONAL_SLIDES_SAND[(i_ds + offset_diag_sand) % 8u];
                                 let check_idx = pos_to_idx_i32(check_pos);
                                 if (check_idx != 0xFFFFFFFFu) {
                                     let type_diag = getVoxelType(atomicLoad(&voxels[check_idx].data));
                                     if (type_diag == VOXEL_TYPE_AIR) {
                                         if(attempt_move(current_idx, check_idx, initial_data)) { return; }
                                     } else if (type_diag == VOXEL_TYPE_WATER) { // Sand/Player swaps with water diagonally
                                         if(attempt_swap(current_idx, check_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         } else if (current_type == VOXEL_TYPE_WATER) {
                              let DIAGONAL_DIRS_WATER = array<vec3<i32>, 4>(vec3(-1,-1,0), vec3(1,-1,0), vec3(0,-1,-1), vec3(0,-1,1));
                              let offset_diag_water = time_varied_hash % 4u;
                              for(var i_dw = 0u; i_dw < 4u; i_dw = i_dw + 1u) {
                                 let check_pos = vec3<i32>(global_id) + DIAGONAL_DIRS_WATER[(i_dw + offset_diag_water) % 4u];
                                 let check_idx = pos_to_idx_i32(check_pos);
                                  if (check_idx != 0xFFFFFFFFu) {
                                     if (getVoxelType(atomicLoad(&voxels[check_idx].data)) == VOXEL_TYPE_AIR) { // Water only moves into air diagonally
                                        if(attempt_move(current_idx, check_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }

                     // PRIORITY 3: Tumbling (Sand and Water)
                     if (global_id.y > 0u) {
                         let HORIZONTAL_TUMBLE_DIRS = array<vec3<i32>,4>(vec3(1,0,0),vec3(-1,0,0),vec3(0,0,1),vec3(0,0,-1));
                         let offset_tumble = (time_varied_hash >> 3u) % 4u;
                         for(var i_t=0u; i_t<4u; i_t++){
                             let horizontal_dir = HORIZONTAL_TUMBLE_DIRS[(i_t + offset_tumble) % 4u];
                             let h_n_pos = vec3<i32>(global_id) + horizontal_dir;
                             let h_n_idx = pos_to_idx_i32(h_n_pos);

                             if(h_n_idx != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[h_n_idx].data)) == VOXEL_TYPE_AIR){
                                 let tumble_target_pos = h_n_pos - vec3(0,1,0);
                                 if(tumble_target_pos.y >= 0){
                                     let tumble_target_idx = pos_to_idx_i32(tumble_target_pos);
                                     if(tumble_target_idx != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[tumble_target_idx].data)) == VOXEL_TYPE_AIR){
                                        if(attempt_move(current_idx, tumble_target_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }

                     // PRIORITY 4: Water Horizontal Spread (specific to water)
                     if (current_type == VOXEL_TYPE_WATER) {
                         let HORIZONTAL_SPREAD_DIRS_WATER = array<vec3<i32>, 4>(vec3(-1,0,0), vec3(1,0,0), vec3(0,0,-1), vec3(0,0,1));
                         let offset_h_water = (time_varied_hash >> 4u) % 4u;
                          for(var i_hw = 0u; i_hw < 4u; i_hw = i_hw + 1u) {
                             let dir = HORIZONTAL_SPREAD_DIRS_WATER[(i_hw + offset_h_water) % 4u];
                             let neighbor_idx_1 = pos_to_idx_i32(vec3<i32>(global_id) + dir);
                             if (neighbor_idx_1 != 0xFFFFFFFFu) {
                                 let neighbor_type_1 = getVoxelType(atomicLoad(&voxels[neighbor_idx_1].data));
                                 if (neighbor_type_1 == VOXEL_TYPE_AIR) {
                                     if (attempt_move(current_idx, neighbor_idx_1, initial_data)) { return; }
                                 } else if (neighbor_type_1 == VOXEL_TYPE_WATER) {
                                     let neighbor_idx_2 = pos_to_idx_i32(vec3<i32>(global_id) + dir * 2);
                                     if (neighbor_idx_2 != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[neighbor_idx_2].data)) == VOXEL_TYPE_AIR) {
                                          if (attempt_move(current_idx, neighbor_idx_2, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }
                 }
             `;

             const resetFlagsShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @compute @workgroup_size(8, 8, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx != 0xFFFFFFFFu) {
                         atomicAnd(&voxels[idx].data, ~((1u) << SHIFT_UPDATED));
                     }
                 }
             `;

             const lightingShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> scene: SceneUniforms;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx == 0xFFFFFFFFu) { return; }

                     let current_packed = unpackVoxel(atomicLoad(&voxels[idx].data));
                     if (current_packed.v_type == VOXEL_TYPE_STONE || current_packed.v_type == VOXEL_TYPE_AIR) {
                         let packed_no_light = packVoxel(current_packed.v_type, current_packed.v_variant, 0u, vec3(0.0));
                         atomicStore(&voxels[idx].data, packed_no_light);
                         return;
                     }

                     var final_light_color = vec3(0.0);
                     let voxel_pos = vec3<f32>(id) + 0.5;
                     for (var i = 0u; i < scene.light_count; i = i + 1u) {
                         let light = scene.lights[i];
                         let dist_sq = dot(voxel_pos - light.pos, voxel_pos - light.pos);
                         let radius_sq = light.radius * light.radius;
                         if (dist_sq < radius_sq) {
                             let falloff = pow(1.0 - (dist_sq / radius_sq), 2.0);
                             final_light_color += light.color * falloff * light.intensity;
                         }
                     }
                     atomicStore(&voxels[idx].data, packVoxel(current_packed.v_type, current_packed.v_variant, 0u, final_light_color));
                 }
             `;

             const paintShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;
                 @group(0) @binding(2) var<storage, read> targeting: TargetingOutput;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id_in_brush: vec3<u32>) {
                     if(tool_info.is_painting == 0u || targeting.hit == 0u) { return; }
                     let brush_radius_f = tool_info.brush_size;
                     let brush_center_world_f = targeting.aim_pos.xyz;
                     let local_pos_in_brush = vec3<f32>(global_id_in_brush) - vec3(brush_radius_f) + 0.5;
                     if (length(local_pos_in_brush) > brush_radius_f) { return; }
                     let p_world_u = vec3<u32>(floor(brush_center_world_f + local_pos_in_brush));
                     let idx = pos_to_idx(p_world_u);
                     if (idx != 0xFFFFFFFFu) {
                         if (tool_info.tool_type == TOOL_TYPE_DESTROY) {
                             atomicStore(&voxels[idx].data, 0u);
                         } else {
                             if (getVoxelType(atomicLoad(&voxels[idx].data)) == VOXEL_TYPE_AIR) {
                                 var new_voxel_type: u32;
                                 if (tool_info.tool_type == TOOL_TYPE_SAND) { new_voxel_type = VOXEL_TYPE_SAND; }
                                 else if (tool_info.tool_type == TOOL_TYPE_WATER) { new_voxel_type = VOXEL_TYPE_WATER; }
                                 else { new_voxel_type = VOXEL_TYPE_STONE; }
                                 let variant = u32(hash3d_to_float(p_world_u) * 8.0);
                                 atomicStore(&voxels[idx].data, packVoxel(new_voxel_type, variant, 1u, vec3(0.0)));
                             }
                         }
                     }
                 }
             `;

             const clearLooseVoxelsShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx != 0xFFFFFFFFu) {
                         let v_type = getVoxelType(atomicLoad(&voxels[idx].data));
                         if(v_type == VOXEL_TYPE_SAND || v_type == VOXEL_TYPE_WATER){
                             atomicStore(&voxels[idx].data, 0u);
                         }
                     }
                 }
             `;

             const renderShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> scene: RenderPassUniforms;
                 @group(0) @binding(2) var<uniform> tool_info: ComputePassUniforms;
                 @group(0) @binding(3) var<storage, read> targeting: TargetingOutput;

                 fn getColorFromVoxel(voxel: UnpackedVoxel, is_water: bool) -> vec3<f32> {
                     let variant_f = f32(voxel.v_variant) / 7.0;
                     if (voxel.v_type == VOXEL_TYPE_STONE) {
                         return vec3(0.45) + (variant_f - 0.5) * 0.15;
                     }
                     if (voxel.v_type == VOXEL_TYPE_SAND) {
                         return vec3(0.8, 0.7, 0.4) + (variant_f - 0.5) * 0.1;
                     }
                     if (is_water) {
                         return vec3(0.15, 0.45, 0.85); // Flat base color for water, variant removed
                     }
                     // This should not be reached for water if logic is correct, but acts as a fallback.
                     return vec3(0.15, 0.45, 0.85) + (variant_f - 0.5) * vec3(0.05, 0.05, 0.1);
                 }

                 fn intersect_aabb(ro: vec3<f32>, rd: vec3<f32>, min_b: vec3<f32>, max_b: vec3<f32>) -> vec2<f32> {
                     let t1=(min_b-ro)/rd; let t2=(max_b-ro)/rd;
                     return vec2(max(max(min(t1.x,t2.x),min(t1.y,t2.y)),min(t1.z,t2.z)),min(min(max(t1.x,t2.x),max(t1.y,t2.y)),max(t1.z,t2.z)));
                 }
                 fn intersect_sphere(ro: vec3<f32>, rd: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {
                     let oc = ro - c; let b = dot(oc, rd); let h = b*b - dot(oc, oc) + r*r;
                     if (h < 0.0) { return -1.0; } else { return -b - sqrt(h); }
                 }
                 
                 // Hash function for procedural noise
                 fn hash13(p3: vec3<f32>) -> f32 {
                     var p = fract(p3 * 0.1031);
                     p += dot(p, p.zyx + 31.32);
                     return fract((p.x + p.y) * p.z);
                 }
                 
                 // 3D value noise for cloud generation
                 fn noise3d(p: vec3<f32>) -> f32 {
                     let i = floor(p);
                     let f = fract(p);
                     let u = f * f * (3.0 - 2.0 * f);
                     
                     return mix(
                         mix(
                             mix(hash13(i + vec3(0.0, 0.0, 0.0)), hash13(i + vec3(1.0, 0.0, 0.0)), u.x),
                             mix(hash13(i + vec3(0.0, 1.0, 0.0)), hash13(i + vec3(1.0, 1.0, 0.0)), u.x),
                             u.y
                         ),
                         mix(
                             mix(hash13(i + vec3(0.0, 0.0, 1.0)), hash13(i + vec3(1.0, 0.0, 1.0)), u.x),
                             mix(hash13(i + vec3(0.0, 1.0, 1.0)), hash13(i + vec3(1.0, 1.0, 1.0)), u.x),
                             u.y
                         ),
                         u.z
                     );
                 }
                 
                 // Fractal Brownian Motion for clouds
                 fn fbm(p: vec3<f32>) -> f32 {
                     var value = 0.0;
                     var amplitude = 0.5;
                     var frequency = 1.0;
                     var p_var = p;
                     
                     for (var i = 0; i < 4; i = i + 1) {
                         value += amplitude * noise3d(p_var * frequency);
                         frequency *= 2.0;
                         amplitude *= 0.5;
                     }
                     
                     return value;
                 }
                 
                 // Enhanced sky rendering with sun and clouds
                 fn compute_sky_color(ray_dir: vec3<f32>, sun_dir: vec3<f32>, time: f32) -> vec3<f32> {
                     // Atmospheric gradient - horizon to zenith
                     let y_factor = max(ray_dir.y, 0.0);
                     let horizon_color = vec3(0.6, 0.75, 0.9);  // Light blue at horizon
                     let zenith_color = vec3(0.2, 0.4, 0.8);     // Deeper blue at zenith
                     var sky_color = mix(horizon_color, zenith_color, pow(y_factor, 0.6));
                     
                     // Add sunset/sunrise gradient near horizon
                     let sunset_factor = pow(1.0 - y_factor, 3.0) * max(sun_dir.y + 0.2, 0.0);
                     let sunset_color = vec3(1.0, 0.6, 0.3);
                     sky_color = mix(sky_color, sunset_color, sunset_factor * 0.4);
                     
                     // Sun disk
                     let sun_dot = dot(ray_dir, normalize(sun_dir));
                     let sun_intensity = pow(max(sun_dot, 0.0), 128.0);
                     let sun_glow = pow(max(sun_dot, 0.0), 8.0) * 0.15;
                     let sun_corona = pow(max(sun_dot, 0.0), 2.0) * 0.05;
                     sky_color += vec3(1.0, 0.95, 0.8) * (sun_intensity + sun_glow + sun_corona);
                     
                     // Procedural clouds (only in upper hemisphere for performance)
                     if (ray_dir.y > 0.05) {
                         // Map ray direction to cloud texture coordinates
                         let cloud_scale = 0.8;
                         let cloud_pos = vec3(ray_dir.x / (ray_dir.y + 0.1), time * 0.02, ray_dir.z / (ray_dir.y + 0.1)) * cloud_scale;
                         
                         // Generate cloud density with multiple octaves
                         var cloud_density = fbm(cloud_pos);
                         
                         // Add second layer of smaller clouds
                         let cloud_detail = noise3d(cloud_pos * 3.0 + vec3(time * 0.05, 0.0, 0.0)) * 0.3;
                         cloud_density = cloud_density * 0.7 + cloud_detail;
                         
                         // Sharpen clouds (make them more defined)
                         cloud_density = smoothstep(0.4, 0.7, cloud_density);
                         
                         // Cloud color influenced by sun
                         let cloud_sun_dot = dot(normalize(vec3(ray_dir.x, 0.0, ray_dir.z)), normalize(vec3(sun_dir.x, 0.0, sun_dir.z)));
                         let cloud_lighting = 0.7 + 0.3 * max(cloud_sun_dot, 0.0);
                         
                         let cloud_color = vec3(0.9, 0.92, 0.95) * cloud_lighting;
                         
                         // Fade clouds based on view angle (less visible when looking straight up or down)
                         let cloud_fade = smoothstep(0.05, 0.3, ray_dir.y) * (1.0 - smoothstep(0.7, 0.95, ray_dir.y));
                         cloud_density *= cloud_fade;
                         
                         // Blend clouds with sky
                         sky_color = mix(sky_color, cloud_color, cloud_density * 0.8);
                     }
                     
                     return sky_color;
                 }
                 @vertex fn vs_main(@builtin(vertex_index) vi: u32) -> @builtin(position) vec4<f32> {
                     return vec4(vec2(f32(vi/2u)*4.0-1.0, f32(vi%2u)*4.0-1.0), 0.0, 1.0);
                 }
                 @fragment fn fs_main(@builtin(position) fc: vec4<f32>) -> @location(0) vec4<f32> {
                     let cam_fwd = normalize(scene.camera_target_pos - scene.camera_position);
                     let aspect = scene.canvas_actual_dims.x / scene.canvas_actual_dims.y;
                     let ray_dir = normalize(scene.camera_right*((fc.x/scene.canvas_actual_dims.x)-0.5)*2.0*aspect + scene.camera_up*((fc.y/scene.canvas_actual_dims.y)-0.5)*-2.0 + cam_fwd*scene.camera_zoom);
                     let t_bounds = intersect_aabb(scene.camera_position, ray_dir, vec3(0.0), vec3(f32(GRID_DIM)));

                     var sky_color = compute_sky_color(ray_dir, scene.sun_direction, f32(tool_info.frame_num));
                     var final_color = vec4(sky_color, 1.0);

                     var dda_hit_this_ray = false;
                     var dda_hit_map_pos = vec3<i32>(0);

                     if (t_bounds.x < t_bounds.y && t_bounds.y > 0.0) {
                         var dda_pos = scene.camera_position + ray_dir * (max(0.0, t_bounds.x) - 0.001);
                         var map_pos = vec3<i32>(floor(dda_pos));
                         let step = vec3<i32>(sign(ray_dir));
                         let delta = abs(1.0 / (ray_dir + 1e-6));
                         var side = (sign(ray_dir) * (vec3<f32>(map_pos) - dda_pos) + (sign(ray_dir) * 0.5 + 0.5)) * delta;

                         for (var i = 0u; i < scene.max_ray_steps; i = i + 1u) {
                             var normal: vec3<f32>;
                             if (side.x < side.y && side.x < side.z) { side.x+=delta.x; map_pos.x+=step.x; normal=vec3(-f32(step.x),0,0); }
                             else if (side.y < side.z) { side.y+=delta.y; map_pos.y+=step.y; normal=vec3(0,-f32(step.y),0); }
                             else { side.z+=delta.z; map_pos.z+=step.z; normal=vec3(0,0,-f32(step.z)); }

                             let idx = pos_to_idx(vec3<u32>(map_pos));
                             if (idx != 0xFFFFFFFFu) {
                                 let voxel = unpackVoxel(atomicLoad(&voxels[idx].data));
                                 if (voxel.v_type != VOXEL_TYPE_AIR) {
                                     var base_color = getColorFromVoxel(voxel, voxel.v_type == VOXEL_TYPE_WATER);

                                     let sun_diffuse = max(dot(normal, normalize(scene.sun_direction)), 0.0) * 0.5 + 0.5;
                                     var y_bright: f32;

                                     if (voxel.v_type == VOXEL_TYPE_WATER) {
                                         // Surface shimmer
                                         let time_factor_surface = f32(tool_info.frame_num) * 0.05;
                                         let spatial_factor_surface = f32(map_pos.x) * 0.3 + f32(map_pos.z) * 0.3;
                                         let surface_shimmer_val = (sin(spatial_factor_surface + time_factor_surface) + cos(spatial_factor_surface * 0.7)) * 0.025 + 0.01;
                                         base_color += vec3(surface_shimmer_val * 0.5, surface_shimmer_val * 0.7, surface_shimmer_val);

                                         // Per-voxel internal body oscillation
                                         let internal_time = f32(tool_info.frame_num) * 0.11 + f32(map_pos.y) * 0.07;
                                         let p_hash_x = sin(f32(map_pos.x) * 0.61 + internal_time + f32(map_pos.z) * 0.23);
                                         let p_hash_y = cos(f32(map_pos.y) * 0.73 - internal_time * 0.71 + f32(map_pos.x) * 0.19);
                                         let p_hash_z = sin(f32(map_pos.z) * 0.57 + internal_time * 1.13 + f32(map_pos.y) * 0.29);
                                         let internal_oscillation = (p_hash_x * p_hash_y * p_hash_z) * 0.045;
                                         base_color += vec3(internal_oscillation * 0.3, internal_oscillation * 0.4, internal_oscillation * 0.7);

                                         // Enhanced Y-brightness for water
                                         let normalized_y = f32(map_pos.y) / f32(GRID_DIM - 1u);
                                         y_bright = pow(normalized_y, 2.5) * 2.8 + 0.2; // Darker bottom, much brighter top (target ~0.2 to 3.0 range)
                                     } else {
                                         // Original y_bright for other materials
                                         y_bright = pow(f32(map_pos.y) / f32(GRID_DIM), 0.75) * 1.25 + 0.25;
                                     }

                                     var lit_color = base_color * sun_diffuse * y_bright + voxel.light;
                                     // No general water multiplier here anymore, y_bright handles it.

                                     final_color = vec4(clamp(lit_color, vec3(0.0), vec3(1.0)), 1.0);
                                     dda_hit_this_ray = true;
                                     dda_hit_map_pos = map_pos;
                                     break;
                                 }
                             }
                         }
                     }

                     if (dda_hit_this_ray && tool_info.preview_active == 1u && targeting.hit == 1u) {
                         let hit_center = vec3<f32>(dda_hit_map_pos) + 0.5;
                         let dist_to_brush = length(hit_center - targeting.aim_pos.xyz);
                         if (dist_to_brush <= tool_info.brush_size) {
                            var tool_color_indicator = vec3(0.0);
                            if (tool_info.tool_type == TOOL_TYPE_DESTROY) { tool_color_indicator = vec3(1.0, 0.2, 0.2); }
                            else if (tool_info.tool_type == TOOL_TYPE_WATER) { tool_color_indicator = vec3(0.3, 0.6, 1.0); }
                            else if (tool_info.tool_type == TOOL_TYPE_SAND) { tool_color_indicator = vec3(0.95, 0.85, 0.3); }
                            else { tool_color_indicator = vec3(0.6, 0.7, 1.0); }
                            let falloff = pow(1.0 - clamp(dist_to_brush/tool_info.brush_size, 0.0, 1.0), 1.5);
                            final_color = vec4<f32>(mix(final_color.rgb, tool_color_indicator, falloff * 0.6), final_color.a);
                         }
                     }

                     if (tool_info.preview_active == 1u && targeting.hit == 1u) {
                         let t_sphere = intersect_sphere(scene.camera_position, ray_dir, targeting.aim_pos.xyz, tool_info.brush_size);
                         if (t_sphere > 0.0) {
                             let hit_pos_on_sphere = scene.camera_position + ray_dir * t_sphere;
                             let sphere_normal = normalize(hit_pos_on_sphere - targeting.aim_pos.xyz);
                             let fresnel = pow(1.0 - abs(dot(sphere_normal, -ray_dir)), 4.0);
                             var sphere_base_tint = vec3(0.0);
                             if(tool_info.tool_type == TOOL_TYPE_DESTROY) { sphere_base_tint=vec3(1.0,0.2,0.2); }
                             else if (tool_info.tool_type == TOOL_TYPE_WATER) { sphere_base_tint=vec3(0.3, 0.6, 1.0); }
                             else if (tool_info.tool_type == TOOL_TYPE_SAND) { sphere_base_tint=vec3(0.95, 0.85, 0.3); }
                             else { sphere_base_tint=vec3(0.6, 0.7, 1.0); }
                             let sphere_blend_alpha = clamp(0.35 + fresnel * 0.6, 0.1, 0.9);
                             final_color = vec4<f32>(mix(final_color.rgb, sphere_base_tint, sphere_blend_alpha), final_color.a);
                         }
                     }
                     return final_color;
                 }
             `;


            // ğŸ¯ ç›®æ ‡å®šä½ç€è‰²å™¨ä»£ç  | Targeting shader code
            // ç”¨é€”: ä»é¼ æ ‡ä½ç½®å‘å°„å…‰çº¿ï¼Œæ‰¾åˆ°ä½“ç´ ç½‘æ ¼çš„äº¤ç‚¹ | Purpose: Cast ray from mouse position to find voxel grid intersection
            const targetingShaderCode = `
                ${commonShaderCode}
                @group(0) @binding(0) var<storage, read> voxels: array<VoxelData>;
                @group(0) @binding(1) var<uniform> uniforms: ComputePassUniforms;
                @group(0) @binding(2) var<storage, read_write> output: TargetingOutput;

                // ğŸ¯ ä¸»è®¡ç®—å…¥å£ | Main compute entry point
                // å•çº¿ç¨‹æ‰§è¡Œï¼šä»é¼ æ ‡ä½ç½®å‘å°„å…‰çº¿ï¼Œæ‰¾åˆ°å‘½ä¸­ç‚¹ | Single thread: cast ray from mouse, find hit point
                @compute @workgroup_size(1)
                fn main() {
                    // ğŸ“· è®¡ç®—ç›¸æœºå‰å‘å‘é‡ | Calculate camera forward vector
                    let cam_fwd = normalize(uniforms.camera_target_pos - uniforms.camera_position);
                    
                    // ğŸ“ è®¡ç®—å±å¹•å®½é«˜æ¯” | Calculate aspect ratio
                    let aspect = uniforms.canvas_dims.x / uniforms.canvas_dims.y;
                    
                    // ğŸ–±ï¸ å°†é¼ æ ‡ä½ç½®ä»å±å¹•ç©ºé—´è½¬æ¢åˆ°NDCç©ºé—´ | Convert mouse position from screen to NDC space
                    let ndc_x = (uniforms.mouse_pos.x / uniforms.canvas_dims.x - 0.5) * 2.0 * aspect;
                    let ndc_y = (uniforms.mouse_pos.y / uniforms.canvas_dims.y - 0.5) * -2.0;
                    
                    // ğŸ¯ æ„å»ºå…‰çº¿æ–¹å‘ | Construct ray direction
                    let ray_dir = normalize(
                        uniforms.camera_right * ndc_x + 
                        uniforms.camera_up * ndc_y + 
                        cam_fwd * uniforms.camera_zoom
                    );
                    
                    // ğŸ“¦ è®¡ç®—å…‰çº¿ä¸ä½“ç´ ç½‘æ ¼AABBçš„äº¤ç‚¹ | Calculate ray-AABB intersection with voxel grid
                    let grid_min = vec3<f32>(0.0);
                    let grid_max = vec3<f32>(f32(GRID_DIM));
                    let t1 = (grid_min - uniforms.camera_position) / ray_dir;
                    let t2 = (grid_max - uniforms.camera_position) / ray_dir;
                    let t_min = max(max(min(t1.x, t2.x), min(t1.y, t2.y)), min(t1.z, t2.z));
                    let t_max = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
                    
                    // ğŸ” åˆå§‹åŒ–è¾“å‡º | Initialize output
                    output.hit = 0u;
                    output.aim_pos = vec4<f32>(0.0);
                    
                    // ğŸš« å¦‚æœå…‰çº¿æ²¡æœ‰å‡»ä¸­ç½‘æ ¼è¾¹ç•Œï¼Œç›´æ¥è¿”å› | Return if ray doesn't hit grid bounds
                    if (t_min >= t_max || t_max <= 0.0) {
                        return;
                    }
                    
                    // ğŸ² DDAå…‰çº¿è¿½è¸ªç®—æ³• | DDA ray marching algorithm
                    // ä»å…‰çº¿ä¸ç½‘æ ¼çš„äº¤ç‚¹å¼€å§‹ | Start from ray-grid intersection
                    var dda_pos = uniforms.camera_position + ray_dir * (max(0.0, t_min) + 0.001);
                    var map_pos = vec3<i32>(floor(dda_pos));
                    
                    // ğŸ“ è®¡ç®—DDAæ­¥è¿›å‚æ•° | Calculate DDA stepping parameters
                    let step = vec3<i32>(sign(ray_dir));
                    let delta = abs(1.0 / (ray_dir + vec3<f32>(1e-6)));
                    var side = (vec3<f32>(step) * (vec3<f32>(map_pos) - dda_pos) + (vec3<f32>(step) * 0.5 + 0.5)) * delta;
                    
                    // ğŸ”„ å…‰çº¿æ­¥è¿›å¾ªç¯ | Ray stepping loop
                    for (var i = 0u; i < uniforms.max_ray_steps_compute; i = i + 1u) {
                        // è®¡ç®—æ³•çº¿ï¼ˆç”¨äºç¡®å®šå‡»ä¸­é¢ï¼‰ | Calculate normal (to determine hit face)
                        var normal: vec3<f32>;
                        
                        // ğŸªœ æ²¿æœ€è¿‘çš„è½´æ­¥è¿› | Step along the closest axis
                        if (side.x < side.y && side.x < side.z) {
                            side.x += delta.x;
                            map_pos.x += step.x;
                            normal = vec3<f32>(-f32(step.x), 0.0, 0.0);
                        } else if (side.y < side.z) {
                            side.y += delta.y;
                            map_pos.y += step.y;
                            normal = vec3<f32>(0.0, -f32(step.y), 0.0);
                        } else {
                            side.z += delta.z;
                            map_pos.z += step.z;
                            normal = vec3<f32>(0.0, 0.0, -f32(step.z));
                        }
                        
                        // ğŸ” æ£€æŸ¥æ˜¯å¦åœ¨ç½‘æ ¼èŒƒå›´å†… | Check if within grid bounds
                        let idx = pos_to_idx_i32(map_pos);
                        if (idx != 0xFFFFFFFFu) {
                            // ğŸ“¦ è¯»å–ä½“ç´ æ•°æ® | Read voxel data
                            let voxel_data = atomicLoad(&voxels[idx].data);
                            let voxel_type = getVoxelType(voxel_data);
                            
                            // ğŸ’¥ æ£€æµ‹å‡»ä¸­ | Check for hit
                            if (voxel_type != VOXEL_TYPE_AIR) {
                                // ğŸ¯ è®¡ç®—å‡»ä¸­ä½ç½® | Calculate hit position
                                var hit_pos = vec3<f32>(map_pos) + vec3<f32>(0.5);
                                
                                // ğŸ”§ æ ¹æ®ç”¨æˆ·è®¾ç½®è°ƒæ•´ç›®æ ‡ä½ç½® | Adjust target position based on user settings
                                // å¦‚æœè®¾ç½®ä¸ºç›®æ ‡è¿œç«¯é¢ï¼Œå‘å¤–åç§»åŠä¸ªä½“ç´ ï¼›å¦åˆ™å‘å†…åç§»
                                // If set to target far face, offset outward by half voxel; otherwise offset inward
                                if (uniforms.target_far_face_on_air_hit == 1u) {
                                    hit_pos += normal * 0.5;
                                } else {
                                    hit_pos -= normal * 0.5;
                                }
                                
                                // âœ… è®°å½•å‡»ä¸­ | Record hit
                                output.hit = 1u;
                                output.aim_pos = vec4<f32>(hit_pos, 1.0);
                                return;
                            }
                        } else {
                            // ğŸš« è¶…å‡ºè¾¹ç•Œï¼Œåœæ­¢è¿½è¸ª | Out of bounds, stop tracing
                            break;
                        }
                    }
                }
            `;
             // ==================================================
             // ğŸ“¦ GPUç¼“å†²åŒºåˆ›å»º | GPU Buffer Creation
             // ==================================================
             // ç¼“å†²åŒº(Buffer)æ˜¯GPUå†…å­˜ä¸­çš„æ•°æ®å— | Buffers are data blocks in GPU memory
             // å®ƒä»¬ç”¨äºåœ¨CPUå’ŒGPUä¹‹é—´ä¼ é€’æ•°æ® | They're used to pass data between CPU and GPU
             
             // ğŸ“ è®¡ç®—ä½“ç´ ç¼“å†²åŒºå¤§å° | Calculate voxel buffer size
             // æ¯ä¸ªä½“ç´ 4å­—èŠ‚(32ä½) | Each voxel is 4 bytes (32 bits)
             const VOXEL_BUFFER_SIZE = NUM_VOXELS * 4;
             
             // ğŸ§± ä½“ç´ ç¼“å†²åŒºï¼šå­˜å‚¨æ‰€æœ‰ä½“ç´ æ•°æ® | Voxel buffer: stores all voxel data
             // ç”¨é€”: STORAGE(è®¡ç®—ç€è‰²å™¨è¯»å†™) | COPY_SRC/DST(å¯ä»¥å¤åˆ¶)
             // Usage: STORAGE (compute shader read/write) | COPY_SRC/DST (can be copied)
             const voxelBuffer = device.createBuffer({ 
                 size: VOXEL_BUFFER_SIZE,  // ç¼“å†²åŒºå¤§å°(å­—èŠ‚) | Buffer size in bytes
                 usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST 
             });
             
             // ğŸŒ ä¸–ç•Œç”Ÿæˆå‚æ•°ç¼“å†²åŒº | World generation parameters buffer
             // åªå­˜å‚¨ä¸€ä¸ªu32å€¼ï¼šåœ°å½¢ç±»å‹ | Stores only one u32 value: terrain type
             const generationUniformsBuffer = device.createBuffer({ 
                 size: 4,  // 4å­—èŠ‚ = 1ä¸ªu32 | 4 bytes = 1 u32
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // ğŸ“· æ¸²æŸ“é€šé“ç»Ÿä¸€ç¼“å†²åŒº | Render pass uniform buffer
             // å­˜å‚¨ç›¸æœºä½ç½®ã€æ–¹å‘ã€å¤ªé˜³æ–¹å‘ç­‰æ¸²æŸ“å‚æ•° | Stores camera position, direction, sun direction, etc.
             const renderPassUniformsBuffer = device.createBuffer({ 
                 size: 104,  // 26ä¸ªfloat(æ¯ä¸ª4å­—èŠ‚) = 104å­—èŠ‚ | 26 floats (4 bytes each) = 104 bytes
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // ğŸ–¥ï¸ è®¡ç®—é€šé“ç»Ÿä¸€ç¼“å†²åŒº | Compute pass uniform buffer
             // å­˜å‚¨ç‰©ç†æ¨¡æ‹Ÿå’Œå·¥å…·äº¤äº’æ‰€éœ€çš„å‚æ•° | Stores parameters for physics simulation and tool interaction
             const computePassUniformsBuffer = device.createBuffer({ 
                 size: 144,  // 36ä¸ªfloat/uint = 144å­—èŠ‚ | 36 floats/uints = 144 bytes
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // ğŸ¯ ç›®æ ‡è¾“å‡ºç¼“å†²åŒº | Targeting output buffer
             // å­˜å‚¨å…‰çº¿è¿½è¸ªæ‰¾åˆ°çš„ç›®æ ‡ä½ç½® | Stores target position found by ray tracing
             const targetingOutputBuffer = device.createBuffer({ 
                 size: 32,  // vec4<f32> + u32 + å¡«å…… | vec4<f32> + u32 + padding
                 usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC 
             });
             
             // ğŸ§ ç©å®¶ä½ç½®è¾“å‡ºç¼“å†²åŒº | Player position output buffer
             // å­˜å‚¨GPUæ‰¾åˆ°çš„ç©å®¶ä½“ç´ ä½ç½® | Stores player voxel position found by GPU
             
             // ğŸ’¡ å…‰æºç»Ÿä¸€ç¼“å†²åŒº | Lights uniform buffer
             // å­˜å‚¨æ‰€æœ‰åŠ¨æ€ç‚¹å…‰æºçš„æ•°æ® | Stores data for all dynamic point lights
             const lightsUniformBuffer = device.createBuffer({ 
                 size: 32 * NUM_LIGHTS + 16,  // æ¯ä¸ªå…‰æº32å­—èŠ‚ + 16å­—èŠ‚å…ƒæ•°æ® | 32 bytes per light + 16 bytes metadata
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });

             // ==================================================
             // ğŸ”§ GPUç®¡çº¿åˆ›å»º | GPU Pipeline Creation
             // ==================================================
             // ç®¡çº¿(Pipeline)å®šä¹‰äº†GPUå¦‚ä½•å¤„ç†æ•°æ® | Pipelines define how GPU processes data
             // æ¯ä¸ªç®¡çº¿åŒ…å«ç€è‰²å™¨ä»£ç å’Œé…ç½® | Each pipeline contains shader code and configuration
             
             // ğŸŒ ä¸–ç•Œç”Ÿæˆç®¡çº¿ | World generation pipeline
             // ç”¨é€”: åˆå§‹åŒ–ä½“ç´ ç½‘æ ¼ï¼Œç”Ÿæˆåœ°å½¢æˆ–å¹³å¦ä¸–ç•Œ | Purpose: Initialize voxel grid, generate terrain or flat world
             const generationPipeline = device.createComputePipeline({ 
                 layout: 'auto',  // è‡ªåŠ¨æ¨æ–­å¸ƒå±€ | Auto-infer layout
                 compute: { 
                     module: device.createShaderModule({ code: generationShaderCode }),  // ç¼–è¯‘ç€è‰²å™¨ä»£ç  | Compile shader code
                     entryPoint: 'main'  // å…¥å£å‡½æ•°å | Entry function name
                 }
             });
             
             // âš¡ ç‰©ç†æ¨¡æ‹Ÿç®¡çº¿ | Physics simulation pipeline
             // ç”¨é€”: æ¨¡æ‹Ÿæ²™å­ä¸‹è½ã€æ°´æµåŠ¨ç­‰ç‰©ç†æ•ˆæœ | Purpose: Simulate sand falling, water flowing, etc.
             const simulationPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: simulationShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // ğŸ”„ é‡ç½®æ ‡å¿—ç®¡çº¿ | Reset flags pipeline
             // ç”¨é€”: æ¸…é™¤æ¯å¸§çš„"å·²æ›´æ–°"æ ‡å¿—ï¼Œå‡†å¤‡ä¸‹ä¸€å¸§ç‰©ç†æ¨¡æ‹Ÿ | Purpose: Clear "updated" flags each frame for next physics step
             const resetFlagsPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: resetFlagsShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // ğŸ’¡ å…‰ç…§è®¡ç®—ç®¡çº¿ | Lighting calculation pipeline
             // ç”¨é€”: è®¡ç®—åŠ¨æ€ç‚¹å…‰æºå¯¹ä½“ç´ çš„ç…§æ˜ | Purpose: Calculate dynamic point light illumination on voxels
             const lightingPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: lightingShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // ğŸ–Œï¸ ç»˜åˆ¶å·¥å…·ç®¡çº¿ | Paint tool pipeline
             // ç”¨é€”: åº”ç”¨ç”¨æˆ·çš„ç»˜åˆ¶æ“ä½œ(æ·»åŠ /åˆ é™¤ä½“ç´ ) | Purpose: Apply user's painting operations (add/remove voxels)
             const paintPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: paintShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // ğŸ§¹ æ¸…é™¤æ¾æ•£ä½“ç´ ç®¡çº¿ | Clear loose voxels pipeline
             // ç”¨é€”: ç§»é™¤æ‰€æœ‰æ²™å­å’Œæ°´ï¼Œåªä¿ç•™çŸ³å¤´ | Purpose: Remove all sand and water, keep only stone
             const clearLooseVoxelsPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: clearLooseVoxelsShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // ğŸ¯ ç›®æ ‡å®šä½ç®¡çº¿ | Targeting pipeline
             // ç”¨é€”: GPUå…‰çº¿è¿½è¸ªæ‰¾åˆ°é¼ æ ‡æŒ‡å‘çš„3Dä½ç½® | Purpose: GPU ray tracing to find 3D position under mouse cursor
             const targetingPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: targetingShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             
             // ğŸ¨ æ¸²æŸ“ç®¡çº¿ | Render pipeline
             // ç”¨é€”: å°†3Dä½“ç´ ä¸–ç•Œæ¸²æŸ“åˆ°2Då±å¹• | Purpose: Render 3D voxel world to 2D screen
             // è¿™æ˜¯å”¯ä¸€çš„æ¸²æŸ“ç®¡çº¿ï¼Œå…¶ä»–éƒ½æ˜¯è®¡ç®—ç®¡çº¿ | This is the only render pipeline, others are compute pipelines
             let renderPipeline = device.createRenderPipeline({
                 layout: 'auto',
                 vertex: { 
                     module: device.createShaderModule({ code: renderShaderCode }), 
                     entryPoint: 'vs_main'  // é¡¶ç‚¹ç€è‰²å™¨å…¥å£ | Vertex shader entry
                 },
                 fragment: { 
                     module: device.createShaderModule({ code: renderShaderCode }), 
                     entryPoint: 'fs_main',  // ç‰‡æ®µç€è‰²å™¨å…¥å£ | Fragment shader entry
                     targets: [{ 
                         format: presentationFormat,  // è¾“å‡ºæ ¼å¼ | Output format
                         // æ··åˆæ¨¡å¼: æ”¯æŒé€æ˜åº¦ | Blend mode: supports transparency
                         blend: {
                             color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                             alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                         }
                      }] 
                 },
                 primitive: { topology: 'triangle-list' },  // ç»˜åˆ¶ä¸‰è§’å½¢ | Draw triangles
             });

             // ==================================================
             // ğŸ”— ç»‘å®šç»„åˆ›å»º | Bind Group Creation
             // ==================================================
             // ç»‘å®šç»„(Bind Group)å°†ç¼“å†²åŒºç»‘å®šåˆ°ç€è‰²å™¨ | Bind groups connect buffers to shaders
             // æ¯ä¸ªç®¡çº¿éœ€è¦çŸ¥é“ä»å“ªé‡Œè¯»å–æ•°æ®ï¼Œç»‘å®šç»„æä¾›è¿™ä¸ªæ˜ å°„ | Each pipeline needs to know where to read data, bind groups provide this mapping
             
             // ğŸŒ ä¸–ç•Œç”Ÿæˆç»‘å®šç»„ | World generation bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(è¯»å†™) + ç”Ÿæˆå‚æ•°(åªè¯») | Binds: voxel buffer (read/write) + generation params (read-only)
             const generationBindGroup = device.createBindGroup({ 
                 layout: generationPipeline.getBindGroupLayout(0),  // ä»ç®¡çº¿è·å–å¸ƒå±€ | Get layout from pipeline
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } },           // @binding(0): ä½“ç´ æ•°æ® | voxel data
                     { binding: 1, resource: { buffer: generationUniformsBuffer } } // @binding(1): ç”Ÿæˆå‚æ•° | generation params
                 ]
             });
             
             // âš¡ ç‰©ç†æ¨¡æ‹Ÿç»‘å®šç»„ | Physics simulation bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(è¯»å†™) + è®¡ç®—å‚æ•°(åªè¯») | Binds: voxel buffer (read/write) + compute params (read-only)
             const simulationBindGroup = device.createBindGroup({ 
                 layout: simulationPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }
                 ]
             });
             
             // ğŸ”„ é‡ç½®æ ‡å¿—ç»‘å®šç»„ | Reset flags bind group
             // åªéœ€è¦ä½“ç´ ç¼“å†²åŒº | Only needs voxel buffer
             const resetFlagsBindGroup = device.createBindGroup({ 
                 layout: resetFlagsPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }
                 ]
             });
             
             // ğŸ’¡ å…‰ç…§è®¡ç®—ç»‘å®šç»„ | Lighting calculation bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(è¯»å†™) + å…‰æºæ•°æ®(åªè¯») | Binds: voxel buffer (read/write) + light data (read-only)
             const lightBindGroup = device.createBindGroup({ 
                 layout: lightingPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: lightsUniformBuffer } }
                 ]
             });
             
             // ğŸ–Œï¸ ç»˜åˆ¶å·¥å…·ç»‘å®šç»„ | Paint tool bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(è¯»å†™) + å·¥å…·å‚æ•°(åªè¯») + ç›®æ ‡ä½ç½®(åªè¯») | Binds: voxel buffer + tool params + target position
             const paintBindGroup = device.createBindGroup({ 
                 layout: paintPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: targetingOutputBuffer } }
                 ]
             });
             
             // ğŸ§¹ æ¸…é™¤æ¾æ•£ä½“ç´ ç»‘å®šç»„ | Clear loose voxels bind group
             const clearLooseBindGroup = device.createBindGroup({ 
                 layout: clearLooseVoxelsPipeline.getBindGroupLayout(0), 
                 entries: [
                     { binding: 0, resource: { buffer: voxelBuffer } }
                 ]
             });
             
             // ğŸ¯ ç›®æ ‡å®šä½ç»‘å®šç»„ | Targeting bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(åªè¯») + è®¡ç®—å‚æ•°(åªè¯») + è¾“å‡ºç¼“å†²åŒº(å†™å…¥) | Binds: voxel buffer + compute params + output buffer
             const targetingBindGroup = device.createBindGroup({ 
                 layout: targetingPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: targetingOutputBuffer } }
                 ]
             });
             
             
             // ğŸ¨ æ¸²æŸ“ç»‘å®šç»„ | Render bind group
             // ç»‘å®š: ä½“ç´ ç¼“å†²åŒº(åªè¯») + æ¸²æŸ“å‚æ•°(åªè¯») + å·¥å…·å‚æ•°(åªè¯») + ç›®æ ‡ä½ç½®(åªè¯»)
             // Binds: voxel buffer + render params + tool params + target position
             const renderBindGroup = device.createBindGroup({ 
                 layout: renderPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: renderPassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 3, resource: { buffer: targetingOutputBuffer } } 
                 ]
             });

            // ==================================================
            // ğŸ¯ CPU-Based Player Physics and Collision | CPUç©å®¶ç‰©ç†å’Œç¢°æ’
            // ==================================================
            
            // Helper to read voxel from GPU buffer (CPU side, async - only for debugging)
            // We'll use a synchronous approach by maintaining a CPU shadow copy during generation
            let voxelShadow = null; // Will store voxel data for CPU collision checks
            
            /**
             * Check if a voxel position is solid (blocks movement)
             * @param {number} x - Voxel X coordinate
             * @param {number} y - Voxel Y coordinate
             * @param {number} z - Voxel Z coordinate
             * @returns {boolean} - True if solid
             */
            function isVoxelSolid(x, y, z) {
                // Clamp to grid bounds
                if (x < 0 || x >= VOXEL_GRID_SIZE || y < 0 || y >= VOXEL_GRID_SIZE || z < 0 || z >= VOXEL_GRID_SIZE) {
                    return true; // Out of bounds is solid
                }
                
                const vx = Math.floor(x);
                const vy = Math.floor(y);
                const vz = Math.floor(z);
                
                // Calculate voxel index
                const idx = vx + vy * VOXEL_GRID_SIZE + vz * VOXEL_GRID_SIZE * VOXEL_GRID_SIZE;
                
                // Read from shadow buffer if available
                if (voxelShadow && idx < voxelShadow.length) {
                    const voxelData = voxelShadow[idx];
                    const voxelType = voxelData & 0x7; // Extract type from bits 0-2
                    // Types: 0=AIR, 1=STONE, 2=SAND, 3=WATER, 4=PLAYER
                    // Solid types: STONE (1), SAND (2)
                    return voxelType === 1 || voxelType === 2;
                }
                
                // Default to not solid if no shadow buffer (shouldn't happen)
                return false;
            }
            
            /**
             * Check if AABB collides with any solid voxels
             * @param {number} minX - Min X of bounding box
             * @param {number} minY - Min Y of bounding box
             * @param {number} minZ - Min Z of bounding box
             * @param {number} maxX - Max X of bounding box
             * @param {number} maxY - Max Y of bounding box
             * @param {number} maxZ - Max Z of bounding box
             * @returns {boolean} - True if collision detected
             */
            function checkAABBCollision(minX, minY, minZ, maxX, maxY, maxZ) {
                // Check all voxels that the AABB overlaps
                const startX = Math.floor(minX);
                const startY = Math.floor(minY);
                const startZ = Math.floor(minZ);
                const endX = Math.floor(maxX);
                const endY = Math.floor(maxY);
                const endZ = Math.floor(maxZ);
                
                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        for (let z = startZ; z <= endZ; z++) {
                            if (isVoxelSolid(x, y, z)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            /**
             * Update player physics and movement (Minecraft-style)
             * @param {number} deltaTime - Time since last frame in seconds
             */
            function updatePlayerPhysics(deltaTime) {
                if (cameraMode !== 'firstperson') return;
                
                // Clamp deltaTime to prevent huge jumps (max 0.1s = 10 FPS minimum)
                deltaTime = Math.min(deltaTime, 0.1);
                
                // ==== Input Processing ====
                // Calculate desired movement direction from WASD keys
                let moveX = 0, moveZ = 0;
                if (keyState.w) { moveX += Math.cos(player.yaw); moveZ += Math.sin(player.yaw); }
                if (keyState.s) { moveX -= Math.cos(player.yaw); moveZ -= Math.sin(player.yaw); }
                if (keyState.a) { moveX -= Math.sin(player.yaw); moveZ += Math.cos(player.yaw); }
                if (keyState.d) { moveX += Math.sin(player.yaw); moveZ -= Math.cos(player.yaw); }
                
                // Normalize input to prevent faster diagonal movement
                const inputMagnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (inputMagnitude > 0) {
                    moveX /= inputMagnitude;
                    moveZ /= inputMagnitude;
                }
                
                // ==== Ground Detection ====
                // Check if player is on ground by testing slightly below feet
                const feetY = player.position[1];
                const halfWidth = player.width / 2;
                player.isGrounded = checkAABBCollision(
                    player.position[0] - halfWidth,
                    feetY - 0.1,
                    player.position[2] - halfWidth,
                    player.position[0] + halfWidth,
                    feetY,
                    player.position[2] + halfWidth
                );
                
                // ==== Horizontal Movement ====
                const targetSpeed = player.walkSpeed;
                const targetVelX = moveX * targetSpeed;
                const targetVelZ = moveZ * targetSpeed;
                
                if (player.isGrounded) {
                    // Ground movement: fast acceleration and friction
                    const accel = player.groundAcceleration * deltaTime;
                    const friction = player.groundFriction * deltaTime;
                    
                    // Accelerate towards target velocity
                    player.velocity[0] += (targetVelX - player.velocity[0]) * Math.min(accel, 1.0);
                    player.velocity[2] += (targetVelZ - player.velocity[2]) * Math.min(accel, 1.0);
                    
                    // Apply friction when not pressing any movement keys
                    if (inputMagnitude === 0) {
                        player.velocity[0] *= Math.max(0, 1 - friction);
                        player.velocity[2] *= Math.max(0, 1 - friction);
                    }
                } else {
                    // Air movement: limited control
                    const airAccel = player.airAcceleration * deltaTime;
                    player.velocity[0] += (targetVelX - player.velocity[0]) * Math.min(airAccel, 1.0);
                    player.velocity[2] += (targetVelZ - player.velocity[2]) * Math.min(airAccel, 1.0);
                }
                
                // ==== Jumping ====
                if (keyState.space && player.isGrounded) {
                    player.velocity[1] = player.jumpVelocity;
                    player.isGrounded = false; // Prevent double jumping
                }
                
                // ==== Gravity ====
                if (!player.isGrounded) {
                    player.velocity[1] -= player.gravity * deltaTime;
                    // Terminal velocity (prevent infinite falling speed)
                    player.velocity[1] = Math.max(player.velocity[1], -78.4); // Minecraft terminal velocity
                }
                
                // ==== Collision Detection and Position Update ====
                const newHalfWidth = player.width / 2;
                
                // Move X axis with collision
                let newX = player.position[0] + player.velocity[0] * deltaTime;
                if (!checkAABBCollision(
                    newX - newHalfWidth, player.position[1], player.position[2] - newHalfWidth,
                    newX + newHalfWidth, player.position[1] + player.height, player.position[2] + newHalfWidth
                )) {
                    player.position[0] = newX;
                } else {
                    player.velocity[0] = 0; // Stop horizontal movement on collision
                }
                
                // Move Z axis with collision
                let newZ = player.position[2] + player.velocity[2] * deltaTime;
                if (!checkAABBCollision(
                    player.position[0] - newHalfWidth, player.position[1], newZ - newHalfWidth,
                    player.position[0] + newHalfWidth, player.position[1] + player.height, newZ + newHalfWidth
                )) {
                    player.position[2] = newZ;
                } else {
                    player.velocity[2] = 0; // Stop horizontal movement on collision
                }
                
                // Move Y axis with collision
                let newY = player.position[1] + player.velocity[1] * deltaTime;
                if (!checkAABBCollision(
                    player.position[0] - newHalfWidth, newY, player.position[2] - newHalfWidth,
                    player.position[0] + newHalfWidth, newY + player.height, player.position[2] + newHalfWidth
                )) {
                    player.position[1] = newY;
                } else {
                    // Hit ceiling or floor
                    if (player.velocity[1] < 0) {
                        // Hit floor, snap to ground
                        player.position[1] = Math.floor(player.position[1] + 0.001);
                        player.isGrounded = true;
                    }
                    player.velocity[1] = 0;
                }
                
                // ==== Step Climbing ====
                // If blocked horizontally and on ground, try to step up
                if ((player.velocity[0] !== 0 || player.velocity[2] !== 0) && player.isGrounded) {
                    for (let stepUp = 0.1; stepUp <= player.stepHeight; stepUp += 0.1) {
                        const testY = player.position[1] + stepUp;
                        // Check if we can move horizontally at this height
                        const canStepX = !checkAABBCollision(
                            newX - newHalfWidth, testY, player.position[2] - newHalfWidth,
                            newX + newHalfWidth, testY + player.height, player.position[2] + newHalfWidth
                        );
                        const canStepZ = !checkAABBCollision(
                            player.position[0] - newHalfWidth, testY, newZ - newHalfWidth,
                            player.position[0] + newHalfWidth, testY + player.height, newZ + newHalfWidth
                        );
                        if (canStepX || canStepZ) {
                            // Step up!
                            player.position[1] = testY;
                            if (canStepX) player.position[0] = newX;
                            if (canStepZ) player.position[2] = newZ;
                            break;
                        }
                    }
                }
                
                // ==== Boundary Clamping ====
                // Prevent player from going out of world bounds
                player.position[0] = Math.max(newHalfWidth, Math.min(VOXEL_GRID_SIZE - newHalfWidth, player.position[0]));
                player.position[1] = Math.max(0, Math.min(VOXEL_GRID_SIZE - player.height, player.position[1]));
                player.position[2] = Math.max(newHalfWidth, Math.min(VOXEL_GRID_SIZE - newHalfWidth, player.position[2]));
            }

             function resizeCanvasAndContext() {
                 const newScale = parseFloat(document.getElementById('resolutionScale').value);
                 uiControls.resolutionScale = newScale;
                 document.getElementById('resolutionScaleValue').textContent = `${(newScale * 100).toFixed(0)}%`;
                 const displayWidth = canvas.parentElement.clientWidth;
                 const displayHeight = canvas.parentElement.clientHeight;
                 const newWidth = Math.max(1, Math.floor(displayWidth * uiControls.resolutionScale));
                 const newHeight = Math.max(1, Math.floor(displayHeight * uiControls.resolutionScale));
                 if (canvas.width !== newWidth || canvas.height !== newHeight) {
                     canvas.width = newWidth;
                     canvas.height = newHeight;
                 }
             }

             function runGeneration() {
                 device.queue.writeBuffer(generationUniformsBuffer, 0, new Uint32Array([currentTerrainType]));
                 const commandEncoder = device.createCommandEncoder();
                 const genPass = commandEncoder.beginComputePass();
                 genPass.setPipeline(generationPipeline);
                 genPass.setBindGroup(0, generationBindGroup);
                 genPass.dispatchWorkgroups(VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4);
                 genPass.end();
                 device.queue.submit([commandEncoder.finish()]);
                 frameCount = 0;
                 
                 // Create shadow copy of voxel buffer for CPU collision detection
                 // This needs to be done async after generation completes
                 createVoxelShadow();
             }
             
             // Helper function to create CPU shadow copy of voxel buffer
             async function createVoxelShadow() {
                 // Create a staging buffer for reading back voxel data
                 const stagingBuffer = device.createBuffer({
                     size: VOXEL_BUFFER_SIZE,
                     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                 });
                 
                 // Copy voxel buffer to staging buffer
                 const commandEncoder = device.createCommandEncoder();
                 commandEncoder.copyBufferToBuffer(voxelBuffer, 0, stagingBuffer, 0, VOXEL_BUFFER_SIZE);
                 device.queue.submit([commandEncoder.finish()]);
                 
                 // Read back the data
                 await stagingBuffer.mapAsync(GPUMapMode.READ);
                 const arrayBuffer = stagingBuffer.getMappedRange();
                 voxelShadow = new Uint32Array(arrayBuffer).slice(); // Copy the data
                 stagingBuffer.unmap();
                 stagingBuffer.destroy();
                 
                 console.log('Voxel shadow buffer created for collision detection');
             }

             runGeneration();

             document.getElementById('resetSimButton').addEventListener('click', runGeneration);
             document.getElementById('worldTypeTerrain').addEventListener('click', () => { currentTerrainType = 1; runGeneration(); document.getElementById('worldTypeTerrain').classList.add('active'); document.getElementById('worldTypeFlat').classList.remove('active'); });
             document.getElementById('worldTypeFlat').addEventListener('click', () => { currentTerrainType = 0; runGeneration(); document.getElementById('worldTypeFlat').classList.add('active'); document.getElementById('worldTypeTerrain').classList.remove('active'); });
             document.getElementById('clearLooseButton').addEventListener('click', () => {
                 const commandEncoder = device.createCommandEncoder();
                 const passClear = commandEncoder.beginComputePass();
                 passClear.setPipeline(clearLooseVoxelsPipeline);
                 passClear.setBindGroup(0, clearLooseBindGroup);
                 passClear.dispatchWorkgroups(VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4);
                 passClear.end();
                 device.queue.submit([commandEncoder.finish()]);
             });

             const toolButtonsMap = {
                 [TOOL_PAINT_SAND]: document.getElementById('toolPaintSand'),
                 [TOOL_PAINT_STONE]: document.getElementById('toolPaintStone'),
                 [TOOL_PAINT_WATER]: document.getElementById('toolPaintWater'),
                 [TOOL_DESTROY]: document.getElementById('toolDestroy')
             };
             function setActiveToolButton(tool) {
                 Object.values(toolButtonsMap).forEach(button => button.classList.remove('active'));
                 if(toolButtonsMap[tool]) toolButtonsMap[tool].classList.add('active');
             }
             Object.entries(toolButtonsMap).forEach(([toolId, buttonElement]) => {
                 buttonElement.addEventListener('click', () => {
                     currentTool = parseInt(toolId);
                     setActiveToolButton(currentTool);
                 });
             });
             setActiveToolButton(currentTool);

             document.getElementById('sunSpeed').addEventListener('input', (e) => { uiControls.sunSpeed = parseFloat(e.target.value); document.getElementById('sunSpeedValue').textContent = uiControls.sunSpeed.toFixed(4); });
             document.getElementById('brushSize').addEventListener('input', (e) => { uiControls.brushSize = parseFloat(e.target.value); document.getElementById('brushSizeValue').textContent = uiControls.brushSize.toFixed(1); });
             document.getElementById('simSteps').addEventListener('input', (e) => { uiControls.simSteps = parseInt(e.target.value); document.getElementById('simStepsValue').textContent = uiControls.simSteps.toString(); });
             document.getElementById('maxRaySteps').addEventListener('input', (e) => { uiControls.maxRaySteps = parseInt(e.target.value); document.getElementById('maxRayStepsValue').textContent = uiControls.maxRaySteps.toString(); });
             document.getElementById('continuousPaintToggle').addEventListener('change', (e) => { uiControls.continuousPaint = e.target.checked; });
             document.getElementById('targetFarFaceToggle').addEventListener('change', (e) => { uiControls.targetFarFaceOnAirHit = e.target.checked; });
             document.getElementById('resolutionScale').addEventListener('change', resizeCanvasAndContext);

             // Camera mode switching
             document.getElementById('cameraModeOrbital').addEventListener('click', () => {
                cameraMode = 'orbital';
                document.getElementById('cameraModeOrbital').classList.add('active');
                document.getElementById('cameraModeFirstPerson').classList.remove('active');
                document.getElementById('firstPersonHUD').style.display = 'none';
                document.getElementById('orbitalInstructions').style.display = 'inline';
                document.getElementById('firstPersonInstructions').style.display = 'none';
                canvas.style.cursor = 'crosshair';
                if (document.pointerLockElement === canvas) {
                   document.exitPointerLock();
                }
             });
             document.getElementById('cameraModeFirstPerson').addEventListener('click', () => {
                cameraMode = 'firstperson';
                document.getElementById('cameraModeFirstPerson').classList.add('active');
                document.getElementById('cameraModeOrbital').classList.remove('active');
                document.getElementById('firstPersonHUD').style.display = 'block';
                document.getElementById('orbitalInstructions').style.display = 'none';
                document.getElementById('firstPersonInstructions').style.display = 'inline';
                canvas.style.cursor = 'none';
             });

             // Use the specific element references from the top for these two
             const localInfoToggleButton = document.getElementById('infoToggleButton'); // This one is already setup at the top
             const localDescriptionArea = document.getElementById('descriptionArea'); // This one is already setup at the top
             // The onclick for infoToggleButton is already set up globally.

             function hideInfoPanel() { if (localDescriptionArea && !localDescriptionArea.classList.contains('hidden') && localInfoToggleButton) { localInfoToggleButton.click(); } }

             canvas.addEventListener('contextmenu', e => {e.preventDefault(); hideInfoPanel(); });
             canvas.addEventListener('mouseenter', () => isPreviewVisible = true);
             canvas.addEventListener('mouseleave', () => isPreviewVisible = false);
             
             // Keyboard controls
             window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') spacebarDown = true;
                if (cameraMode === 'firstperson') {
                   if (e.code === 'KeyW') keyState.w = true;
                   if (e.code === 'KeyA') keyState.a = true;
                   if (e.code === 'KeyS') keyState.s = true;
                   if (e.code === 'KeyD') keyState.d = true;
                   if (e.code === 'Space') { keyState.space = true; e.preventDefault(); }
                   // Shift is no longer used for movement in physics mode
                   // if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keyState.shift = true;
                }
             });
             window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') { spacebarDown = false; if (mouseState.isPanning && mouseState.buttons[0]) mouseState.isPanning = false; }
                if (cameraMode === 'firstperson') {
                   if (e.code === 'KeyW') keyState.w = false;
                   if (e.code === 'KeyA') keyState.a = false;
                   if (e.code === 'KeyS') keyState.s = false;
                   if (e.code === 'KeyD') keyState.d = false;
                   if (e.code === 'Space') keyState.space = false;
                   // Shift is no longer used for movement in physics mode
                   // if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keyState.shift = false;
                }
             });
             canvas.addEventListener('mousedown', (e) => {
                 hideInfoPanel();
                 mouseState.buttons[e.button] = true;
                 mouseState.lastX = e.clientX; mouseState.lastY = e.clientY;
                 
                 // In first-person mode, request pointer lock on click
                 if (cameraMode === 'firstperson' && document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                 }
                 
                 if (e.button === 0 && !spacebarDown && cameraMode === 'orbital') {
                     if (uiControls.continuousPaint) mouseState.isPainting = true;
                     else if (!mouseState.hasFiredSingleShot) { mouseState.isPainting = true; mouseState.hasFiredSingleShot = true; }
                     else { mouseState.isPainting = false; }
                 }
                 
                 // Paint in first-person mode
                 if (e.button === 0 && cameraMode === 'firstperson') {
                     if (uiControls.continuousPaint) mouseState.isPainting = true;
                     else if (!mouseState.hasFiredSingleShot) { mouseState.isPainting = true; mouseState.hasFiredSingleShot = true; }
                     else { mouseState.isPainting = false; }
                 }
                 
                 mouseState.isOrbiting = (e.button === 2 && cameraMode === 'orbital');
                 mouseState.isPanning = (cameraMode === 'orbital' && (e.button === 1 || (spacebarDown && e.button === 0)));
             });
             window.addEventListener('mouseup', (e) => {
                 mouseState.buttons[e.button] = false;
                 if (e.button === 0) { mouseState.isPainting = false; mouseState.hasFiredSingleShot = false; }
                 mouseState.isOrbiting = false;
                 mouseState.isPanning = false;
             });
             window.addEventListener('mousemove', (e) => {
                 if (cameraMode === 'firstperson' && document.pointerLockElement === canvas) {
                    // First-person mouse look
                    const sensitivity = 0.002;
                    player.yaw -= e.movementX * sensitivity;
                    player.pitch -= e.movementY * sensitivity;
                    player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
                 } else if (cameraMode === 'orbital') {
                    const dx = e.clientX - mouseState.lastX; const dy = e.clientY - mouseState.lastY;
                    const rect = canvas.getBoundingClientRect();
                    mouseState.x = (e.clientX - rect.left); mouseState.y = (e.clientY - rect.top);
                    if (mouseState.isOrbiting) {
                        camera.alpha -= dx * 0.005;
                        camera.beta = Math.max(-1.56, Math.min(1.56, camera.beta + dy * 0.005));
                    }
                    else if (mouseState.isPanning) {
                        camera.target[0] -= (currentRight[0]*dx - currentUp[0]*dy) * PAN_SENSITIVITY;
                        camera.target[1] -= (currentRight[1]*dx - currentUp[1]*dy) * PAN_SENSITIVITY;
                        camera.target[2] -= (currentRight[2]*dx - currentUp[2]*dy) * PAN_SENSITIVITY;
                    }
                    mouseState.lastX = e.clientX; mouseState.lastY = e.clientY;
                 }
                 
                 // Always update mouse position for cursor tracking (when not in pointer lock)
                 if (document.pointerLockElement !== canvas) {
                    const rect = canvas.getBoundingClientRect();
                    mouseState.x = (e.clientX - rect.left); mouseState.y = (e.clientY - rect.top);
                 }
             });
             canvas.addEventListener('wheel', (e) => { e.preventDefault(); camera.radius=Math.max(10, Math.min(VOXEL_GRID_SIZE*5, camera.radius+e.deltaY*0.1)); }, {passive: false});

             const resizeObserver = new ResizeObserver(entries => {
                 for (let entry of entries) { resizeCanvasAndContext(); }
             });
             if (canvas.parentElement) {
                resizeObserver.observe(canvas.parentElement);
             } else {
                 console.warn("Canvas parent element not found for ResizeObserver.");
             }
             resizeCanvasAndContext();

            // ğŸ® Update first-person camera and player movement
            // æ›´æ–°ç¬¬ä¸€äººç§°ç›¸æœºå’Œç©å®¶ç§»åŠ¨ | Update first-person camera and player movement
            // ç›¸æœºç»‘å®šåˆ°ç©å®¶ä½“ç´ ä½ç½®ï¼Œé”®ç›˜æ§åˆ¶ç©å®¶ä½“ç´ ç§»åŠ¨ | Camera binds to player voxel position, keyboard controls player voxel movement
             let lastFrameTime = performance.now();
             
             // ==================================================
             // ğŸ¬ ä¸»æ¸²æŸ“å¾ªç¯ | Main Render Loop
             // ==================================================
             // è¿™ä¸ªå‡½æ•°æ¯å¸§éƒ½ä¼šè¢«è°ƒç”¨(é€šå¸¸60æ¬¡/ç§’) | This function is called every frame (typically 60 times/second)
             // å®ƒæ›´æ–°ç‰©ç†ã€å…‰ç…§ã€æ¸²æŸ“æ•´ä¸ªåœºæ™¯ | It updates physics, lighting, and renders the entire scene
             async function frame() {
                 // â±ï¸ è®¡ç®—å¸§æ—¶é—´å·®(deltaTime) | Calculate frame time delta (deltaTime)
                 const now = performance.now();
                 const deltaTime = (now - lastFrameTime) / 1000.0;  // è½¬æ¢ä¸ºç§’ | Convert to seconds
                 
                 // ğŸ® æ›´æ–°ç¬¬ä¸€äººç§°ç›¸æœº(å¦‚æœåœ¨FPSæ¨¡å¼) | Update first-person camera (if in FPS mode)
                 updatePlayerPhysics(deltaTime);
                 
                 // ğŸ“· æ ¹æ®ç›¸æœºæ¨¡å¼è®¡ç®—ç›¸æœºä½ç½®å’Œæ–¹å‘ | Calculate camera position and orientation based on mode
                 if (cameraMode === 'firstperson') {
                    // ç¬¬ä¸€äººç§°æ¨¡å¼: ç›´æ¥ä½¿ç”¨ä½ç½®å’Œæœå‘ | First-person mode: use position and orientation directly
                    currentCamX = player.position[0];
                    currentCamY = player.position[1] + player.eyeHeight;
                    currentCamZ = player.position[2];
                    
                    // ä»yaw(æ°´å¹³)å’Œpitch(å‚ç›´)è§’åº¦è®¡ç®—å‰å‘é‡ | Calculate forward vector from yaw and pitch angles
                    currentForward = [
                       Math.cos(player.pitch) * Math.cos(player.yaw),
                       Math.sin(player.pitch),
                       Math.cos(player.pitch) * Math.sin(player.yaw)
                    ];
                    
                    // è®¡ç®—å³å‘é‡(ç›´æ¥ä»yawè§’åº¦è®¡ç®—) | Calculate right vector (directly from yaw angle)
                    currentRight = [
                       Math.sin(player.yaw),
                       0,
                       -Math.cos(player.yaw)
                    ];
                    
                    // è®¡ç®—ä¸Šå‘é‡(å‰ä¹˜) | Calculate up vector (cross product)
                    currentUp = [
                       currentForward[1] * currentRight[2] - currentForward[2] * currentRight[1],
                       currentForward[2] * currentRight[0] - currentForward[0] * currentRight[2],
                       currentForward[0] * currentRight[1] - currentForward[1] * currentRight[0]
                    ];
                    // å½’ä¸€åŒ–ä¸Šå‘é‡ | Normalize up vector
                    let up_n_raw = Math.hypot(...currentUp);
                    let up_n_val = up_n_raw === 0 ? 1.0 : up_n_raw;
                    currentUp = [currentUp[0]/up_n_val, currentUp[1]/up_n_val, currentUp[2]/up_n_val];
                    
                 } else {
                    // è½¨é“ç›¸æœºæ¨¡å¼: å›´ç»•ç›®æ ‡ç‚¹æ—‹è½¬ | Orbital camera mode: rotate around target point
                    // ä½¿ç”¨çƒåæ ‡è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡ | Convert spherical coordinates to Cartesian
                    currentCamX = camera.target[0] + camera.radius * Math.cos(camera.beta) * Math.sin(camera.alpha);
                    currentCamY = camera.target[1] + camera.radius * Math.sin(camera.beta);
                    currentCamZ = camera.target[2] + camera.radius * Math.cos(camera.beta) * Math.cos(camera.alpha);

                    // è®¡ç®—ç›¸æœºå‰å‘é‡(ä»ç›¸æœºæŒ‡å‘ç›®æ ‡) | Calculate camera forward (from camera to target)
                    const fwd_un = [camera.target[0]-currentCamX, camera.target[1]-currentCamY, camera.target[2]-currentCamZ];
                    let fwd_n_raw = Math.hypot(...fwd_un);
                    let fwd_n_val = fwd_n_raw === 0 ? 1.0 : fwd_n_raw;
                    currentForward = [fwd_un[0]/fwd_n_val, fwd_un[1]/fwd_n_val, fwd_un[2]/fwd_n_val];

                    const wUp = [0,1,0];
                    // è®¡ç®—å³å‘é‡ | Calculate right vector
                    currentRight = [currentForward[1]*wUp[2]-currentForward[2]*wUp[1], currentForward[2]*wUp[0]-currentForward[0]*wUp[2], currentForward[0]*wUp[1]-currentForward[1]*wUp[0]];
                    let r_n_raw = Math.hypot(...currentRight);
                    let r_n_val = r_n_raw === 0 ? 1.0 : r_n_raw;
                    currentRight = [currentRight[0]/r_n_val, currentRight[1]/r_n_val, currentRight[2]/r_n_val];

                    // è®¡ç®—ä¸Šå‘é‡ | Calculate up vector
                    currentUp = [currentRight[1]*currentForward[2]-currentRight[2]*currentForward[1], currentRight[2]*currentForward[0]-currentRight[0]*currentForward[2], currentRight[0]*currentForward[1]-currentRight[1]*currentForward[0]];
                    let up_n_raw = Math.hypot(...currentUp);
                    let up_n_val = up_n_raw === 0 ? 1.0 : up_n_raw;
                    currentUp = [currentUp[0]/up_n_val, currentUp[1]/up_n_val, currentUp[2]/up_n_val];
                 }

                 // â˜€ï¸ æ›´æ–°å¤ªé˜³è§’åº¦(æ—¥å¤œå¾ªç¯) | Update sun angle (day/night cycle)
                 // ğŸ¨ å¯è°ƒå‚æ•°: sunSpeedæ§åˆ¶æ—¥å¤œå¾ªç¯é€Ÿåº¦ | Adjustable: sunSpeed controls day/night cycle speed
                 sunAngle += uiControls.sunSpeed * 0.2;
                 // ä»è§’åº¦è®¡ç®—å¤ªé˜³æ–¹å‘å‘é‡ | Calculate sun direction vector from angle
                 const sunDirection = [Math.cos(sunAngle), 0.707, Math.sin(sunAngle)];
                 
                 // è®¡ç®—ç›¸æœºç›®æ ‡ä½ç½® | Calculate camera target position
                 const cameraTarget = cameraMode === 'firstperson' 
                    ? [currentCamX + currentForward[0], currentCamY + currentForward[1], currentCamZ + currentForward[2]]
                    : camera.target;
                 
                 // ğŸ’¡ æ›´æ–°åŠ¨æ€å…‰æºä½ç½® | Update dynamic light positions
                 const lightData = new Float32Array(8 * NUM_LIGHTS);
                 for(let i = 0; i < NUM_LIGHTS; i++) {
                     // å…‰æºå‘ä¸‹ç§»åŠ¨ | Lights move downward
                     lights[i].position[1] += lights[i].velocity * deltaTime;
                     // å¦‚æœå…‰æºè½åˆ°åº•éƒ¨ï¼Œé‡ç½®åˆ°é¡¶éƒ¨ | If light falls below bottom, reset to top
                     if (lights[i].position[1] < -lights[i].radius) {
                         lights[i].position[0] = Math.random() * VOXEL_GRID_SIZE;
                         lights[i].position[1] = VOXEL_GRID_SIZE + lights[i].radius;
                         lights[i].position[2] = Math.random() * VOXEL_GRID_SIZE;
                     }
                     // å°†å…‰æºæ•°æ®å†™å…¥Float32Array | Write light data to Float32Array
                     const offset = i * 8;
                     lightData.set(lights[i].position, offset); 
                     lightData[offset + 3] = lights[i].radius;
                     lightData.set(lights[i].color, offset + 4); 
                     lightData[offset + 7] = 1.0;  // å¼ºåº¦ | Intensity
                 }
                 // ğŸ“¤ ä¸Šä¼ å…‰æºæ•°æ®åˆ°GPU | Upload light data to GPU
                 device.queue.writeBuffer(lightsUniformBuffer, 0, lightData.buffer);
                 device.queue.writeBuffer(lightsUniformBuffer, 32 * NUM_LIGHTS, new Uint32Array([NUM_LIGHTS]));

                 // ğŸ“· å‡†å¤‡æ¸²æŸ“å‚æ•°å¹¶ä¸Šä¼ åˆ°GPU | Prepare render parameters and upload to GPU
                 const renderUBO = new Float32Array(renderPassUniformsBuffer.size/4);
                 const renderUBOInt = new Uint32Array(renderUBO.buffer);
                 renderUBO.set([currentCamX,currentCamY,currentCamZ], 0); 
                 renderUBO.set([2.0], 3);  // FOV/zoom
                 renderUBO.set(currentRight, 4); 
                 renderUBO.set(currentUp, 8);
                 renderUBO.set(cameraTarget, 12); 
                 renderUBO.set(sunDirection, 16); 
                 renderUBO.set([canvas.width,canvas.height], 20);
                 renderUBOInt[22] = uiControls.maxRaySteps;  // æœ€å¤§å…‰çº¿æ­¥æ•° | Max ray steps
                 device.queue.writeBuffer(renderPassUniformsBuffer, 0, renderUBO);

                 // ğŸ–¥ï¸ å‡†å¤‡è®¡ç®—å‚æ•°å¹¶ä¸Šä¼ åˆ°GPU | Prepare compute parameters and upload to GPU
                 const computeUBO = new Float32Array(computePassUniformsBuffer.size/4);
                 const computeUBOInt = new Uint32Array(computeUBO.buffer);
                 computeUBO.set([currentCamX,currentCamY,currentCamZ], 0); 
                 computeUBO.set([2.0], 3); 
                 computeUBO.set(currentRight, 4); 
                 computeUBO.set(currentUp, 8);
                computeUBO.set(cameraTarget, 12);
                 // åœ¨ç¬¬ä¸€äººç§°æ¨¡å¼ä¸‹ï¼Œå§‹ç»ˆç„å‡†å±å¹•ä¸­å¿ƒ | In first-person mode, always aim at screen center
                 const mx = cameraMode === 'firstperson' ? canvas.width / 2 : mouseState.x * (canvas.width / canvas.clientWidth);
                 const my = cameraMode === 'firstperson' ? canvas.height / 2 : mouseState.y * (canvas.height / canvas.clientHeight);
                 computeUBO.set([mx, my], 16); 
                 computeUBO.set([canvas.width, canvas.height], 18); 
                 computeUBO.set([uiControls.brushSize], 20);
                 let paintingGPU = (mouseState.buttons[0] && (cameraMode === 'firstperson' || !spacebarDown)) && (uiControls.continuousPaint || mouseState.isPainting);
                 computeUBOInt[21] = paintingGPU ? 1:0;
                 computeUBOInt[22] = currentTool; 
                 computeUBOInt[23] = isPreviewVisible ? 1:0;
                 computeUBOInt[24] = uiControls.targetFarFaceOnAirHit ? 1:0;
                 computeUBOInt[25] = frameCount;
                 computeUBOInt[26] = uiControls.maxRaySteps;
                 device.queue.writeBuffer(computePassUniformsBuffer, 0, computeUBO);
                 if (!uiControls.continuousPaint && mouseState.isPainting) mouseState.isPainting = false;

                 // ==================================================
                 // ğŸš€ GPUå‘½ä»¤ç¼–ç å’Œæ‰§è¡Œ | GPU Command Encoding and Execution
                 // ==================================================
                 // CommandEncoderè®°å½•è¦å‘é€åˆ°GPUçš„å‘½ä»¤ | CommandEncoder records commands to send to GPU
                 const commandEncoder = device.createCommandEncoder();

                 // ğŸ¯ ç¬¬1æ­¥: ç›®æ ‡å®šä½é€šé“ | Step 1: Targeting pass
                 // ä½¿ç”¨GPUå…‰çº¿è¿½è¸ªæ‰¾åˆ°é¼ æ ‡æŒ‡å‘çš„3Dä½ç½® | Use GPU ray tracing to find 3D position under mouse
                 const passTarget = commandEncoder.beginComputePass();
                 passTarget.setPipeline(targetingPipeline); 
                 passTarget.setBindGroup(0, targetingBindGroup);
                 passTarget.dispatchWorkgroups(1);  // åªéœ€è¦1ä¸ªå·¥ä½œç»„ | Only need 1 workgroup
                 passTarget.end();


                 // ğŸ–Œï¸ ç¬¬3æ­¥: ç»˜åˆ¶å·¥å…·åº”ç”¨ | Step 3: Paint tool application
                 if (paintingGPU) {
                     const passPaint = commandEncoder.beginComputePass();
                     passPaint.setPipeline(paintPipeline); 
                     passPaint.setBindGroup(0, paintBindGroup);
                     const d = Math.ceil(uiControls.brushSize * 2.0);
                     passPaint.dispatchWorkgroups(Math.ceil(d/4), Math.ceil(d/4), Math.ceil(d/4));
                     passPaint.end();
                 }

                 // ğŸ’¡ ç¬¬4æ­¥: å…‰ç…§è®¡ç®—é€šé“ | Step 4: Lighting calculation pass
                 const passLight = commandEncoder.beginComputePass();
                 passLight.setPipeline(lightingPipeline); 
                 passLight.setBindGroup(0, lightBindGroup);
                 passLight.dispatchWorkgroups(VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4);
                 passLight.end();

                 // ğŸ¨ ç¬¬5æ­¥: æ¸²æŸ“é€šé“ | Step 5: Render pass
                 // è¿™æ˜¯å”¯ä¸€çš„æ¸²æŸ“é€šé“ï¼Œå°†3Dåœºæ™¯ç»˜åˆ¶åˆ°å±å¹• | This is the only render pass, draws 3D scene to screen
                 const passRender = commandEncoder.beginRenderPass({ 
                     colorAttachments: [{ 
                         view: context.getCurrentTexture().createView(),  // è·å–ç”»å¸ƒçº¹ç† | Get canvas texture
                         clearValue: [0.1, 0.1, 0.2, 1.0],  // æ¸…é™¤é¢œè‰²(æ·±è“è‰²) | Clear color (dark blue)
                         loadOp: 'clear',   // æ¸…é™¤ä¹‹å‰çš„å†…å®¹ | Clear previous content
                         storeOp: 'store'   // ä¿å­˜æ¸²æŸ“ç»“æœ | Store render result
                     }] 
                 });
                 passRender.setPipeline(renderPipeline); 
                 passRender.setBindGroup(0, renderBindGroup);
                 passRender.draw(3);  // ç»˜åˆ¶3ä¸ªé¡¶ç‚¹(å…¨å±ä¸‰è§’å½¢) | Draw 3 vertices (fullscreen triangle)
                 passRender.end();

                 // ğŸš€ æäº¤æ‰€æœ‰å‘½ä»¤åˆ°GPUæ‰§è¡Œ | Submit all commands to GPU for execution
                 device.queue.submit([commandEncoder.finish()]);
                 

                 // ğŸ“Š æ›´æ–°FPSæ˜¾ç¤º | Update FPS display
                 document.getElementById('fps').textContent = (1000 / (now - lastFrameTime)).toFixed(1);
                 lastFrameTime = now;
                 frameCount++;
                 
                 // ğŸ”„ è¯·æ±‚ä¸‹ä¸€å¸§ | Request next frame
                 requestAnimationFrame(frame);
             }
             frame(); // å¯åŠ¨æ¸²æŸ“å¾ªç¯ | Start the render loop
         } // End of initAndRun

         // Call the main async function and catch any errors
         initAndRun().catch(error => {
             console.error("VibeSand critical runtime failure:", error);
         });
      </script>
   </body>
</html>
